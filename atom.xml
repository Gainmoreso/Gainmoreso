<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-30T01:10:45.861Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>AlbertH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从2-3-4树到红黑树</title>
    <link href="http://example.com/2021/04/27/%E4%BB%8E2-3-4%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2021/04/27/%E4%BB%8E2-3-4%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-04-27T13:25:04.000Z</published>
    <updated>2021-04-30T01:10:45.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从2-3-4树到红黑树"><a href="#从2-3-4树到红黑树" class="headerlink" title="从2-3-4树到红黑树"></a>从2-3-4树到红黑树</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从2-3-4树到红黑树&quot;&gt;&lt;a href=&quot;#从2-3-4树到红黑树&quot; class=&quot;headerlink&quot; title=&quot;从2-3-4树到红黑树&quot;&gt;&lt;/a&gt;从2-3-4树到红黑树&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AVL tree</title>
    <link href="http://example.com/2021/04/25/AVL-tree/"/>
    <id>http://example.com/2021/04/25/AVL-tree/</id>
    <published>2021-04-25T02:04:41.000Z</published>
    <updated>2021-05-12T22:53:02.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL-TREE"><a href="#AVL-TREE" class="headerlink" title="AVL TREE"></a>AVL TREE</h1><span id="more"></span><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><pre><code>  平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），其本质还是平衡二叉树  且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li>插入</li><li>旋转</li><li>删除</li><li>查找</li></ul><h3 id="插入，删除，查找"><a href="#插入，删除，查找" class="headerlink" title="插入，删除，查找"></a>插入，删除，查找</h3><pre><code> 与二叉树类似</code></pre><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><img src="/2021/04/25/AVL-tree/01.png" class=""><img src="/2021/04/25/AVL-tree/02.png" class=""><img src="/2021/04/25/AVL-tree/03.png" class=""><img src="/2021/04/25/AVL-tree/04.png" class=""><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法）</span></span><br><span class="line"><span class="comment">  且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node * left;</span><br><span class="line">    node * right;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">AVL_TREE</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL_TREE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">node * <span class="title">Creat_BinarySearch_Tree</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Balance</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Delete</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    node * root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">node * <span class="title">Getnewnode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Insert</span><span class="params">(node * root,<span class="keyword">int</span> data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Findheight</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getbalanceFactor</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">rightRotate</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">leftRotate</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Findmin</span><span class="params">(node * root)</span></span>; <span class="comment">//后继节点</span></span><br><span class="line">    <span class="function">node * <span class="title">Delete_Element</span><span class="params">(node * root,<span class="keyword">int</span> element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Getnewnode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * newnode=(node *)<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    newnode-&gt;data=data;</span><br><span class="line">    newnode-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    newnode-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Insert</span><span class="params">(node *root,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        root=<span class="built_in">Getnewnode</span>(data);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;root-&gt;data)</span><br><span class="line">        root-&gt;left=<span class="built_in">Insert</span>(root-&gt;left,data);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;right=<span class="built_in">Insert</span>(root-&gt;right,data);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Creat_BinarySearch_Tree</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;How many numbers : &quot;</span>;</span><br><span class="line">    cin &gt;&gt; size;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Input the numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> *a_pointer=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a_pointer[i];</span><br><span class="line">        root=<span class="built_in">Insert</span>(root,a_pointer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AVL_TREE::Findheight</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Findheight</span>(root-&gt;right),<span class="built_in">Findheight</span>(root-&gt;left))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AVL_TREE::getbalanceFactor</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Findheight</span>(root-&gt;left)-<span class="built_in">Findheight</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::rightRotate</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * temp=root-&gt;left;</span><br><span class="line">    root-&gt;left=temp-&gt;right;</span><br><span class="line">    temp-&gt;right=root;</span><br><span class="line">    root=temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::leftRotate</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * temp=root-&gt;right;</span><br><span class="line">    root-&gt;right=temp-&gt;left;</span><br><span class="line">    temp-&gt;left=root;</span><br><span class="line">    root=temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Balance</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;left)&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//右旋LL</span></span><br><span class="line">root=<span class="built_in">rightRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &lt;<span class="number">-1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;right)&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//左旋RR</span></span><br><span class="line">root=<span class="built_in">leftRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LR</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;left) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">root-&gt;left = <span class="built_in">leftRotate</span>(root-&gt;left);</span><br><span class="line">root=<span class="built_in">rightRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RL</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;right)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">root-&gt;right = <span class="built_in">rightRotate</span>(root-&gt;right);</span><br><span class="line">        root=<span class="built_in">leftRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Findmin</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Delete_Element</span><span class="params">(node * root,<span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element&lt;root-&gt;data)</span><br><span class="line">        root-&gt;left=<span class="built_in">Delete_Element</span>(root-&gt;left,element);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element&gt;root-&gt;data)</span><br><span class="line">        root-&gt;right=<span class="built_in">Delete_Element</span>(root-&gt;right,element);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//(root-&gt;left!=NULL&amp;&amp;root-&gt;right!=NULL)</span></span><br><span class="line">            &#123;</span><br><span class="line">            node * temp=<span class="built_in">Findmin</span>(root-&gt;right);</span><br><span class="line">            root-&gt;data=temp-&gt;data;</span><br><span class="line">            root-&gt;right=<span class="built_in">Delete_Element</span>(root-&gt;right,temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Delete</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Which number to delete: &quot;</span> ;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line">        root=<span class="built_in">Delete_Element</span>(root,number);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Do you want to delete another element(Yes or no): &quot;</span>;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;n&#x27;</span>||ch==<span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::LevelOrder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root); <span class="comment">//Push the address of root</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node * current=Q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        Q.<span class="built_in">pop</span>(); <span class="comment">// Removing the element of front.</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Preorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Inorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Postorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Print</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LevelOrder traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;PreOrder traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">Preorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;InOrder traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Postorder traversal: &quot;</span> ;</span><br><span class="line">    <span class="built_in">Postorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The height of this tree is: &quot;</span>&lt;&lt; <span class="built_in">Findheight</span>(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The height of left tree is: &quot;</span>&lt;&lt;<span class="built_in">Findheight</span>(root-&gt;left) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The height of right tree is: &quot;</span>&lt;&lt;<span class="built_in">Findheight</span>(root-&gt;right) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVL_TREE t;</span><br><span class="line">    t.root=<span class="literal">NULL</span>;</span><br><span class="line">    t.root=t.<span class="built_in">Creat_BinarySearch_Tree</span>(t.root);</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line"></span><br><span class="line">    t.root=t.<span class="built_in">Balance</span>(t.root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;After rotation: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line"></span><br><span class="line">    t.root=t.<span class="built_in">Delete</span>(t.root);</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line"></span><br><span class="line">    t.root=t.<span class="built_in">Balance</span>(t.root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;After rotation: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AVL-TREE&quot;&gt;&lt;a href=&quot;#AVL-TREE&quot; class=&quot;headerlink&quot; title=&quot;AVL TREE&quot;&gt;&lt;/a&gt;AVL TREE&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Counting sort （计数排序）</title>
    <link href="http://example.com/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>http://example.com/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/</id>
    <published>2021-04-24T13:33:35.000Z</published>
    <updated>2021-04-24T15:21:59.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Counting-sort"><a href="#Counting-sort" class="headerlink" title="Counting sort"></a>Counting sort</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>  计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）</code></pre><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>找出原数组的最大值，记为max</li><li>创建一个新数组count ，其长度是max+1 ，其元素默认值都是一</li><li>遍历原数组的元素，原数组的元素值作为count数组的下标，原数组的元素出现的次数作为count数组的元素值</li><li>创建一个新数组result，长度为原数组的长度</li><li>遍历count数组，其中大于0的元素的下标值作为result数组的元素值，没一次count中该元素值减一，直到该元素等于0</li><li>打印数组result</li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/01.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/02.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/03.png" class=""><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 找出数组A中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmax</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;arr[i])</span><br><span class="line">           max=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmin</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min&gt;arr[i])</span><br><span class="line">            min=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Countsort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="built_in">Findmax</span>(arr,len);</span><br><span class="line">    <span class="comment">// 初始化计数数组count</span></span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max+<span class="number">1</span>;i++)</span><br><span class="line">        count[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对计数数组各元素赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    <span class="comment">// 创建结果数组并初始化</span></span><br><span class="line">    <span class="keyword">int</span> *result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        result[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建结果数组的起始索引</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历计数数组，将计数数组的索引填充到结果数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            result[index++]=i;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印结果数组</span></span><br><span class="line">    <span class="built_in">print</span>(result,len);</span><br><span class="line">     <span class="keyword">delete</span> [] count;</span><br><span class="line">     <span class="keyword">delete</span> [] result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">Countsort</span>(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code>  基础版能够解决一般的情况，但是它有一个缺陷，那就是存在空间浪费的问题。  比如一组数据&#123;101,109,108,102,110,107,103&#125;，其中最大值为110，按照基础版的思路，我们需要创建一个长度为111的计数数组，但是我们可以发现，它前面的[0,100]的空间完全浪费了，那怎样优化呢？  将数组长度定为max-min+1，即不仅要找出最大值，还要找出最小值，根据两者的差来确定计数数组的长度。</code></pre><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ul><li>找出原数组的最大值max，最小值min</li><li>创建一个count数组，其大小为max-min+1,并初始化所有元素为0</li><li>遍历原数组的元素，原数组的元素值减去min作为count数组的下标，原数组的元素出现的次数作为count数组的元素值</li><li>创建一个新数组result，长度为原数组的长度</li><li>遍历count数组，其中大于0的元素的下标值加上min作为result数组的元素值，每一次count中该元素值减一，直到该元素等于0</li><li>打印result数组</li></ul><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/04.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/05.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/06.png" class=""><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 找出数组arr中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmax</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;arr[i])</span><br><span class="line">           max=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出数组arr的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmin</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min&gt;arr[i])</span><br><span class="line">            min=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Countsort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min=<span class="built_in">Findmin</span>(arr,len);</span><br><span class="line">    <span class="keyword">int</span> max=<span class="built_in">Findmax</span>(arr,len);</span><br><span class="line">    <span class="keyword">int</span> x=max-min+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化计数数组count</span></span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">        count[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="comment">// A中的元素要减去最小值，再作为新索引</span></span><br><span class="line">        count[arr[i]-<span class="built_in">Findmin</span>(arr,len)]++;</span><br><span class="line">     <span class="comment">// 创建结果数组并初始化</span></span><br><span class="line">    <span class="keyword">int</span> *result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        result[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 遍历计数数组，将计数数组的索引填充到结果数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 再将减去的最小值补上</span></span><br><span class="line">            result[index++]=i+min;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(result,len);</span><br><span class="line">    <span class="keyword">delete</span> [] count;</span><br><span class="line">    <span class="keyword">delete</span> [] result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>]=&#123;<span class="number">101</span>,<span class="number">109</span>,<span class="number">107</span>,<span class="number">103</span>,<span class="number">108</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">110</span>,<span class="number">107</span>,<span class="number">103</span>&#125;;</span><br><span class="line">    <span class="built_in">Countsort</span>(b,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><pre><code>  计数排序虽然它可以将排序算法的时间复杂度降低到O(N)，但是有两个前提需要满足：一是需要排序的元素必须是整数，二是排序元素的取值要在一定范围内，并且比较集中。只有这两个条件都满足，才能最大程度发挥计数排序的优势。</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xiaochuan94/p/11198610.html">博客园</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Counting-sort&quot;&gt;&lt;a href=&quot;#Counting-sort&quot; class=&quot;headerlink&quot; title=&quot;Counting sort&quot;&gt;&lt;/a&gt;Counting sort&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BinarySort</title>
    <link href="http://example.com/2021/04/23/BinarySort/"/>
    <id>http://example.com/2021/04/23/BinarySort/</id>
    <published>2021-04-23T07:42:24.000Z</published>
    <updated>2021-04-23T08:20:10.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BinarySort"><a href="#BinarySort" class="headerlink" title="BinarySort"></a>BinarySort</h1><span id="more"></span><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre><code>  二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用，而且表中元素按关键字有序排列</code></pre><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><pre><code>        首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功</code></pre><h3 id="算法要求"><a href="#算法要求" class="headerlink" title="算法要求"></a>算法要求</h3><ul><li><p>必须采用<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">顺序存储结构</a></p></li><li><p>必须按关键字大小有序排列</p></li></ul><h3 id="比较次数"><a href="#比较次数" class="headerlink" title="比较次数"></a>比较次数</h3><img src="/2021/04/23/BinarySort/01.png" class=""><pre><code>  当顺序表有n个关键字时： 查找失败时，至少比较a次关键字； 查找成功时，最多比较关键字次数是b 注意：a,b,n均为正整数</code></pre><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><pre><code>  二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x.  时间复杂度即是while循环的次数。  总共有n个元素，  渐渐跟下去就是n,n/2,n/4,....n/2^k（接下来操作元素的剩余个  数），其中k就是循环的次数  由于你n/2^k取整后&gt;=1  即令n/2^k=1  可得k=log2n,（是以2为底，n的对数）  所以时间复杂度可以表示O(h)=O(log2n)</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid]==value)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value&gt;arr[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinarySearch1</span>(arr,mid+<span class="number">1</span>,high,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinarySearch1</span>(arr,low,mid<span class="number">-1</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(high+low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(value==arr[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;arr[mid])</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><pre><code>   插入排序是指在待排序的元素中，假设前面n-1(其中n&gt;=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序</code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><pre><code>时间复杂度：   在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(N)   最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为 O(N^2)   平均来说，A[1..j-1]中的一半元素小于A[j]，一半元素大于A[j]。插入排序在平均情况运行时间与最坏情况运行时间一样，是输入规模的二次函数 空间复杂度：  插入排序的空间复杂度为常数阶O(1)</code></pre><h3 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h3><pre><code>  如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code>  插入排序适用于已经有部分数据已经排好，并且排好的部分越大越好。一般在输入规模大于1000的场合下不建议使用插入排序</code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StraightSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp;j--)</span><br><span class="line">&#123;</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><pre><code>  二分法插入排序，简称二分排序，是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上</code></pre><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><pre><code>  二分插入排序是稳定的与二分查找的复杂度相同； 最好的情况是当插入的位置刚好是二分位置 所用时间为O(log₂n);最坏的情况是当插入的位置不在二分位置 所需比较次数为O(n)平均时间O(n^2)</code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binsert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,left,right,mid,x;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        x=a[i];</span><br><span class="line">        left=<span class="number">0</span>;right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x&gt;a[mid]) &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=i<span class="number">-1</span>; j&gt;=left; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BinarySort&quot;&gt;&lt;a href=&quot;#BinarySort&quot; class=&quot;headerlink&quot; title=&quot;BinarySort&quot;&gt;&lt;/a&gt;BinarySort&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Binary search tree</title>
    <link href="http://example.com/2021/04/20/Binary-search-tree/"/>
    <id>http://example.com/2021/04/20/Binary-search-tree/</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2021-04-20T16:01:27.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-search-tree"><a href="#Binary-search-tree" class="headerlink" title="Binary search tree"></a>Binary search tree</h1><span id="more"></span><h2 id="Implementation-in-c-c"><a href="#Implementation-in-c-c" class="headerlink" title="Implementation in c/c++"></a>Implementation in c/c++</h2><pre><code>        最流行的方式是动态的创造节点并用指针把它们链接起来</code></pre><img src="/2021/04/20/Binary-search-tree/01.png" class=""><pre><code>        实现方式：使用递归的方式创造如下图的节点</code></pre><img src="/2021/04/20/Binary-search-tree/02.png" class=""><h3 id="Use-struct-to-create-a-node"><a href="#Use-struct-to-create-a-node" class="headerlink" title="Use struct to create a node"></a>Use struct to create a node</h3><pre><code>        c语言中通过malloc函数或者c++中通过new运算符在堆区(heap)创造节点</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    node * left;   </span><br><span class="line">    node * right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2021/04/20/Binary-search-tree/03.png" class=""><h3 id="Use-function-to-create-a-new-node-in-heap"><a href="#Use-function-to-create-a-new-node-in-heap" class="headerlink" title="Use function to create a new node in heap"></a>Use function to create a new node in heap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node * <span class="title">Getnewnode</span><span class="params">(<span class="keyword">int</span> date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node * newnode=<span class="keyword">new</span> node;</span><br><span class="line">    newnode-&gt;date=date;  </span><br><span class="line">    newnode-&gt;left=<span class="literal">NULL</span>;  </span><br><span class="line">    newnode-&gt;right=<span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> newnode;   <span class="comment">//如果root定义为全局变量，则此处可以为 root=newnode; return root;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Create-a-tree"><a href="#Create-a-tree" class="headerlink" title="Create a tree"></a>Create a tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">node * <span class="title">Insert</span><span class="params">(node * root,<span class="keyword">int</span> date)</span>  <span class="comment">//返回root的地址，主函数需要更新此地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;   <span class="comment">//递归</span></span><br><span class="line">        root=<span class="built_in">Getnewnode</span>(date);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(date&lt;root-&gt;date)&#123;</span><br><span class="line">        root-&gt;left=<span class="built_in">Insert</span>(root-&gt;left,date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        root-&gt;right=<span class="built_in">Insert</span>(root-&gt;right,date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * root=<span class="literal">NULL</span>;</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">15</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">10</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">20</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">18</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Search-whether-it-exists"><a href="#Search-whether-it-exists" class="headerlink" title="Search whether it exists"></a>Search whether it exists</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool Search(node * root,int date)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return false;</span><br><span class="line">    if(date&#x3D;&#x3D;root-&gt;date)</span><br><span class="line">        return true;</span><br><span class="line">    else if(date&lt;root-&gt;date)</span><br><span class="line">         Search(root-&gt;left,date);</span><br><span class="line">    else</span><br><span class="line">         Search(root-&gt;right,date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Find-min-and-max-element-of-BST"><a href="#Find-min-and-max-element-of-BST" class="headerlink" title="Find min and max element of BST"></a>Find min and max element of BST</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMin</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMax</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Delete-a-node"><a href="#Delete-a-node" class="headerlink" title="Delete a node"></a>Delete a node</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node * <span class="title">Findmin</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">//返回该节点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">node * Findmax(node * root)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(root==NULL)</span></span><br><span class="line"><span class="comment">    return NULL;</span></span><br><span class="line"><span class="comment">while(root-&gt;right!)</span></span><br><span class="line"><span class="comment"> root=root-&gt;right;</span></span><br><span class="line"><span class="comment">return root;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">node * <span class="title">Delete</span><span class="params">(node * root,<span class="keyword">int</span> date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(date&lt;root-&gt;date)</span><br><span class="line">        root-&gt;left=<span class="built_in">Delete</span>(root-&gt;left,date);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(date&gt;root-&gt;date)</span><br><span class="line">        root-&gt;right=<span class="built_in">Delete</span>(root-&gt;right,date);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=<span class="literal">NULL</span>;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//(root-&gt;left!=NULL&amp;&amp;root-&gt;right!=NULL)</span></span><br><span class="line">            &#123;  temp指向左子树的最大值或者右子树的最小值</span><br><span class="line">            node * temp=<span class="built_in">Findmin</span>(root-&gt;right);        <span class="comment">//node * temp=Findmax(root-&gt;left);</span></span><br><span class="line">            root-&gt;date=temp-&gt;date;                   <span class="comment">//root-&gt;date=temp-&gt;date;</span></span><br><span class="line">            root-&gt;right=<span class="built_in">Delete</span>(root-&gt;right,temp-&gt;date);<span class="comment">//root-&gt;left=Delete(root-&gt;left,temp-&gt;date);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Binary-Tree-Traversal"><a href="#Binary-Tree-Traversal" class="headerlink" title="Binary Tree Traversal"></a>Binary Tree Traversal</h2><h3 id="Level-Order-Traversal-By-Queue-（广度优先遍历）"><a href="#Level-Order-Traversal-By-Queue-（广度优先遍历）" class="headerlink" title="Level-Order Traversal By Queue （广度优先遍历）"></a>Level-Order Traversal By Queue （广度优先遍历）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span>  <span class="comment">//包含队列的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No node: &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node * current=Q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; current-&gt;date &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preorder-Inorder-Postorder（深度优先遍历）"><a href="#Preorder-Inorder-Postorder（深度优先遍历）" class="headerlink" title="Preorder,Inorder,Postorder（深度优先遍历）"></a>Preorder,Inorder,Postorder（深度优先遍历）</h3><ul><li>遍历顺序：</li></ul><img src="/2021/04/20/Binary-search-tree/04.png" class=""><ul><li>Preorder (前序遍历)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line"><span class="built_in">Preorder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line"><span class="built_in">Preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// F D B A C E J G I K</span></span><br></pre></td></tr></table></figure><p>栈区调用图解：</p><img src="/2021/04/20/Binary-search-tree/05.png" class=""><ul><li>Inorder（中序遍历）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">Inorder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line"><span class="built_in">Inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A B C D E F G H I J K</span></span><br></pre></td></tr></table></figure><ul><li>Postorder（后序遍历）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">Postorder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">Postorder</span>(root-&gt;right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// A C B E D I G K J F</span></span><br></pre></td></tr></table></figure><h2 id="Find-height-of-a-binary-tree"><a href="#Find-height-of-a-binary-tree" class="headerlink" title="Find height of a binary tree"></a>Find height of a binary tree</h2><img src="/2021/04/20/Binary-search-tree/06.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findheight</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Findheight</span>(root-&gt;right),<span class="built_in">Findheight</span>(root-&gt;left))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Complete-code"><a href="#Complete-code" class="headerlink" title="Complete code"></a>Complete code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int date;</span><br><span class="line">    node * left;</span><br><span class="line">    node * right;</span><br><span class="line">&#125;;</span><br><span class="line">node * Getnewnode(int date)</span><br><span class="line">&#123;</span><br><span class="line">    node * newnode&#x3D;(node *)new node();</span><br><span class="line">    newnode-&gt;date&#x3D;date;</span><br><span class="line">    newnode-&gt;left&#x3D;NULL;</span><br><span class="line">    newnode-&gt;right&#x3D;NULL;</span><br><span class="line">    return newnode;</span><br><span class="line">&#125;</span><br><span class="line">node * Insert(node *root,int date)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;Getnewnode(date);</span><br><span class="line">    else if(date&lt;root-&gt;date)</span><br><span class="line">        root-&gt;left&#x3D;Insert(root-&gt;left,date);</span><br><span class="line">    else</span><br><span class="line">        root-&gt;right&#x3D;Insert(root-&gt;right,date);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">int FindMin(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    while(root-&gt;left!&#x3D;NULL)</span><br><span class="line">        root&#x3D;root-&gt;left;</span><br><span class="line">    return root-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line">int FindMax(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    while(root-&gt;right!&#x3D;NULL)</span><br><span class="line">        root&#x3D;root-&gt;right;</span><br><span class="line">    return root-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line">node * Findmin(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    while(root-&gt;left!&#x3D;NULL)&#123;</span><br><span class="line">        root&#x3D;root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">node * Delete(node * root,int date)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    else if(date&lt;root-&gt;date)</span><br><span class="line">        root-&gt;left&#x3D;Delete(root-&gt;left,date);</span><br><span class="line">    else if(date&gt;root-&gt;date)</span><br><span class="line">        root-&gt;right&#x3D;Delete(root-&gt;right,date);</span><br><span class="line">    else&#123;</span><br><span class="line">        if(root-&gt;left&#x3D;&#x3D;NULL&amp;&amp;root-&gt;right&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">            node * temp&#x3D;root;</span><br><span class="line">            root&#x3D;NULL;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;left&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">            node * temp&#x3D;NULL;</span><br><span class="line">            root&#x3D;root-&gt;right;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;right&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">            node * temp&#x3D;root;</span><br><span class="line">            root&#x3D;root-&gt;left;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#x2F;&#x2F;(root-&gt;left!&#x3D;NULL&amp;&amp;root-&gt;right!&#x3D;NULL)</span><br><span class="line">            &#123;</span><br><span class="line">            node * temp&#x3D;Findmin(root-&gt;right);</span><br><span class="line">            root-&gt;date&#x3D;temp-&gt;date;</span><br><span class="line">            root-&gt;right&#x3D;Delete(root-&gt;right,temp-&gt;date);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Findheight(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    return max(Findheight(root-&gt;right),Findheight(root-&gt;left))+1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;前序遍历</span><br><span class="line">void Preorder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL) return;</span><br><span class="line">    printf(&quot;%d &quot;,root-&gt;date);</span><br><span class="line">    Preorder(root-&gt;left);</span><br><span class="line">    Preorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">void Inorder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL) return;</span><br><span class="line">    Inorder(root-&gt;left);</span><br><span class="line">    printf(&quot;%d &quot;,root-&gt;date);</span><br><span class="line">    Inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;后序遍历</span><br><span class="line">void Postorder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL) return;</span><br><span class="line">    Postorder(root-&gt;left);</span><br><span class="line">    Postorder(root-&gt;right);</span><br><span class="line">    printf(&quot;%d &quot;,root-&gt;date);</span><br><span class="line">&#125;</span><br><span class="line">void LevelOrder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;No node: &quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    Q.push(root);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        node * current&#x3D;Q.front();</span><br><span class="line">        cout &lt;&lt; current-&gt;date &lt;&lt; &quot; &quot;;</span><br><span class="line">        if(current-&gt;left!&#x3D;NULL)</span><br><span class="line">            Q.push(current-&gt;left);</span><br><span class="line">        if(current-&gt;right!&#x3D;NULL)</span><br><span class="line">            Q.push(current-&gt;right);</span><br><span class="line">        Q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    node * root&#x3D;NULL;</span><br><span class="line">    root&#x3D;Insert(root,15);</span><br><span class="line">    Insert(root,10);</span><br><span class="line">    Insert(root,20);</span><br><span class="line">    Insert(root,7);</span><br><span class="line">    Insert(root,13);</span><br><span class="line">    Insert(root,18);</span><br><span class="line">    Insert(root,22);</span><br><span class="line">    Insert(root,5);</span><br><span class="line">    Insert(root,9);</span><br><span class="line">    Insert(root,11);</span><br><span class="line">    Insert(root,14);</span><br><span class="line">    cout &lt;&lt; &quot;LevelOrder: &quot;;</span><br><span class="line">    LevelOrder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Preorder: &quot;;</span><br><span class="line">    Preorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Inorder: &quot;;</span><br><span class="line">    Inorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Postorder: &quot;;</span><br><span class="line">    Postorder(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The min of this tree is &quot; &lt;&lt; FindMin(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;the max of this tree is &quot; &lt;&lt; FindMax(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The height of this tree is &quot; &lt;&lt; Findheight(root) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    int number;</span><br><span class="line">    cout &lt;&lt; &quot;Which number to delete: &quot;;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line">    root&#x3D;Delete(root,number);</span><br><span class="line">    cout &lt;&lt; &quot;After delete : &quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;LevelOrder: &quot;;</span><br><span class="line">    LevelOrder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Preorder: &quot;;</span><br><span class="line">    Preorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Inorder: &quot;;</span><br><span class="line">    Inorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Postorder: &quot;;</span><br><span class="line">    Postorder(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The min of this tree is &quot; &lt;&lt; FindMin(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;the max of this tree is &quot; &lt;&lt; FindMax(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The height of this tree is &quot; &lt;&lt; Findheight(root) &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Binary-search-tree&quot;&gt;&lt;a href=&quot;#Binary-search-tree&quot; class=&quot;headerlink&quot; title=&quot;Binary search tree&quot;&gt;&lt;/a&gt;Binary search tree&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Introduction to Trees</title>
    <link href="http://example.com/2021/04/20/Introduction-to-trees/"/>
    <id>http://example.com/2021/04/20/Introduction-to-trees/</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2021-04-20T12:06:15.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-Trees"><a href="#Introduction-to-Trees" class="headerlink" title="Introduction to Trees"></a>Introduction to Trees</h1><span id="more"></span><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>  树是一种数据结构，树（tree）是包含n(n&gt;=1)个节点，(n-1)条边的有穷集<br>  树也可以这样定义：树是由根节点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的节点，所定义的关系称为父子关系。父子关系在树的节点之间建立了一个层次结构。在这种层次结构中有一个节点具有特殊的地位，这个节点称为该树的根节点，或称为树根 其中：</p><ol><li>每个节点有零个或多个子节点；</li><li> 没有父节点的节点称为根节点；</li><li> 每一个非根节点有且只有一个父节点；</li><li> 除了根节点外，每个子节点可以分为多个不相交的子树。</li></ol><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p>节点：构造树的基本单位<br>树的深度：从根节点到叶子结点路径的最大边数<br>树的高度：从根节点到给节点的边数<br>结点的度：结点拥有的子树的数目<br>叶子：度为零的结点<br>分支结点：度不为零的结点<br>树的度：树中结点的最大的度</p><h3 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h3><p>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树<br>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树<br>二叉树：每个节点最多含有两个子树的树称为二叉树<br>满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树<br>完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树<br>二叉查找树：（二叉搜索树 二叉排序树）一棵空树，或者是有序的二叉树，且没有键值相等的节点<br>AVL 树：根节点的左子树与右子树的高度只差的绝对值小于2的二叉查找树<br>红黑树：红黑树（Red Black Tree） 是一种自平衡二叉查找树<br>哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树</p><h2 id="二叉树的介绍"><a href="#二叉树的介绍" class="headerlink" title="二叉树的介绍"></a>二叉树的介绍</h2><p>二叉树是每个节点最多有两个子树的树结构。它具有五种基本形态<br>1、空二叉树<br>2、只有一个根结点的二叉树<br>3、只有左子树<br>4、只有右子树<br>5、完全二叉树</p><h3 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h3><ol><li>二叉树的第i层上至多有2i-1（i≥1）个节点 </li><li>深度为h的二叉树中至多含有2h-1个节点 </li><li>若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2+1 </li><li>具有n个节点的完全二叉树深为log2x+1（其中x表示不大于n的最大整数）</li></ol><h3 id="满二叉树（完美二叉树）"><a href="#满二叉树（完美二叉树）" class="headerlink" title="满二叉树（完美二叉树）"></a>满二叉树（完美二叉树）</h3><p>定义：高度为h，并且由2{h+1}-1个结点的二叉树，被称为满二叉树</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。<br>特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树</p><img src="/2021/04/20/Introduction-to-trees/03.png" class=""><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>定义：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]</p><p>在二叉查找树中：</p><ol><li><p>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p></li><li><p>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p></li><li><p>任意节点的左、右子树也分别为二叉查找树</p></li><li><p> 没有键值相等的节点（no duplicate nodes）</p></li></ol><p>产生二叉树的原因：有二分的思想，对比数组链表，插入删除，查找的平均时间复杂度更低</p><img src="/2021/04/20/Introduction-to-trees/06.png" class=""><img src="/2021/04/20/Introduction-to-trees/04.png" class=""><h3 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h3><p>定义：AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1 即（|Height(Lefttree)-Height(Righttree)|&lt;=1）因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡</p><p>**AVL树本质上还是一棵二叉搜索树，它的特点是： **</p><ol><li><p>本身首先是一棵二叉搜索树。</p></li><li><p>带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1</p></li></ol><p>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）</p><p>产生原因：对二叉查找树的优化</p><img src="/2021/04/20/Introduction-to-trees/05.png" class=""><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>定义：R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)</p><p><strong>红黑树的特性</strong>:</p><ol><li>每个节点或者是黑色，或者是红色</li><li>根节点是黑色</li><li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点</li><li>如果一个节点是红色的，则它的子节点必须是黑色的</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li></ol><p> 示意图如下</p><img src="/2021/04/20/Introduction-to-trees/01.jpg" class=""><p><strong>对比avl树：</strong>首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。<strong>所以红黑树的插入效率更高</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Introduction-to-Trees&quot;&gt;&lt;a href=&quot;#Introduction-to-Trees&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Trees&quot;&gt;&lt;/a&gt;Introduction to Trees&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-16T01:53:49.838Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>AlbertH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Algorithm</title>
    <link href="http://example.com/2021/06/28/Algorithm/"/>
    <id>http://example.com/2021/06/28/Algorithm/</id>
    <published>2021-06-28T08:59:11.000Z</published>
    <updated>2021-07-16T01:53:49.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输出“蛇形”矩阵"><a href="#输出“蛇形”矩阵" class="headerlink" title="输出“蛇形”矩阵"></a>输出“蛇形”矩阵</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>根据输入的数字(&lt; 1000)，输出这样的”蛇形”矩阵，如下。输入n，输出（n * n）阶矩阵，满足由外到内依次增大。</p><p>　　如： 输入2，则输出如下矩阵</p><p>　　1　　2</p><p>　　4　　3</p><p>　　输入3，则输出如下矩阵　　</p><p>　　1　　2　　3</p><p>　　8　　9　　4</p><p>　　7　　6　　5</p><p>　　输入4，则输出如下矩阵</p><p>　　1　　    2　　   3        4</p><p>　　12　　13　　14        5　　</p><p>　　11　　16　　15        6　　</p><p>　　10　　   9　　  8        7</p><h2 id="条件分析"><a href="#条件分析" class="headerlink" title="条件分析"></a>条件分析</h2><ol><li>输入n ,表示矩阵的阶数</li><li>动态分配二维数组空间</li><li>根据“蛇形”给二维数组赋值</li><li>遍历数组</li></ol><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><ol><li><p>清楚二维数组的下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[i<span class="number">-1</span>][j<span class="number">-1</span>]  a[i<span class="number">-1</span>][j]  a[i<span class="number">-1</span>][j]</span><br><span class="line">a[i][j<span class="number">-1</span>]    a[i][j]    a[i][j+<span class="number">1</span>]</span><br><span class="line">a[i+<span class="number">1</span>][j<span class="number">-1</span>]  a[i+<span class="number">1</span>][j]  a[i+<span class="number">1</span>][j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p>一圈一圈遍历，因此需要标记毎圈遍历的边界坐标,也就是起点，终点坐标</p></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>for循环赋值二维数组的最外面一圈,分成四大步，向右，向下，向左，向上</li><li>每次进行一圈后，需要递增遍历的坐标标记</li><li>大循环while判断标记是否到达最里面一圈,若是，则退出，若否则继续第一步</li></ol><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span>** a = <span class="keyword">new</span> <span class="keyword">int</span>*[n];   <span class="comment">//动态创建二维数组,a指向动态一维数组的指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n];   <span class="comment">//为每个一维动态数组元素动态分配大小为n的空间</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;     <span class="comment">//毎圈向右遍历的起点的横坐标  k++ 后成为向下遍历起点的横坐标</span></span><br><span class="line">    <span class="keyword">int</span> g = <span class="number">0</span>;  <span class="comment">//毎圈向左遍历的终点的纵坐标  g++ 后成为向上遍历终点的纵坐标</span></span><br><span class="line">    <span class="keyword">int</span> l = n<span class="number">-1</span>; <span class="comment">//毎圈向左遍历的起点的横坐标  l-- 后成为向上遍历起点的横坐标</span></span><br><span class="line">    <span class="keyword">int</span> j = n<span class="number">-1</span>; <span class="comment">//毎圈向下遍历的起点的纵坐标  j-- 后成为向左遍历起点的纵坐标</span></span><br><span class="line">    <span class="keyword">while</span>(k&lt;=j)         <span class="comment">//判断标记是否到达最里面一圈            </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt;= j;i++)   <span class="comment">//向右遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[k][i] = m;            <span class="comment">// k 作为横坐标</span></span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;                        <span class="comment">//第二圈向右遍历的起点横坐标加一</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt;= j;i++ )  <span class="comment">//向下遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = m;            <span class="comment">// j 作为纵坐标</span></span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        j--;                        <span class="comment">//成为向左遍历起点的纵坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = j;i &gt;= g;i--)   <span class="comment">//向左遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[l][i] = m;            <span class="comment">// l 作为横坐标</span></span><br><span class="line">                m++;</span><br><span class="line">        &#125;</span><br><span class="line">        l--;                        <span class="comment">// 成为向上遍历起点的横坐标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &gt;= k;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][g] = m;            <span class="comment">// g 作为纵坐标</span></span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        g++;                        <span class="comment">// 第二圈向上遍历的的纵坐标加一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)     <span class="comment">// 打印输出这个二维数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">cout &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; a[i][j];  <span class="comment">// 设置输出格式宽度为4，向左对齐 需包含iomanip 头文件</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol><li>该问题涉及到动态构建二维数组</li><li>该问题重点在于对二维数组下标的理解</li><li>解决该问题需按步骤来一步步调试，每一步都可以输出验证自己的推理的结果</li></ol><h1 id="BFS广度优先搜索"><a href="#BFS广度优先搜索" class="headerlink" title="BFS广度优先搜索"></a>BFS广度优先搜索</h1><p>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p><p>算法步骤：</p><ol><li><p> 首先将根节点放入队列中。</p></li><li><p> 从队列中取出第一个节点，并检验它是否为目标。</p></li></ol><p>   如果找到目标，则结束搜寻并回传结果。<br>   否则将它所有尚未检验过的直接子节点加入队列中。</p><ol start="3"><li><p> 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p></li><li><p>重复步骤2。</p><img src="/2021/06/28/Algorithm/bfs_01.png" class=""><h2 id="迷宫的最短路"><a href="#迷宫的最短路" class="headerlink" title="迷宫的最短路"></a>迷宫的最短路</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3></li></ol><ul><li><p>给定一个大小为 N*M 的迷宫，迷宫由通道和墙壁组成，每一步可以向邻接的上下左右的四格通道移动。求出从起点到终点的最小步数，本题假定从起点一定可以到达终点</p></li><li><p>限制条件：N,M &lt; 100</p></li></ul><h3 id="原码-1"><a href="#原码-1" class="headerlink" title="原码"></a>原码</h3>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">char</span> map[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> sx, sy, ex, ey;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;; <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now;</span><br><span class="line">now.x = sx; now.y = sy; now.step = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(now);</span><br><span class="line">vis[now.x][now.y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">node nextt;</span><br><span class="line">nextt.x = t.x + dx[i]; nextt.y = t.y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nextt.x &gt;= <span class="number">0</span> &amp;&amp; nextt.x &lt; n &amp;&amp; nextt.y &gt;= <span class="number">0</span> &amp;&amp; nextt.y &lt; m &amp;&amp; !vis[nextt.x][nextt.y] &amp;&amp; map[nextt.x][nextt.y] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">nextt.step = t.step + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(nextt.x == ex &amp;&amp; nextt.y == ey)</span><br><span class="line">                    <span class="keyword">return</span> nextt.step;</span><br><span class="line">                vis[nextt.x][nextt.y] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(nextt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, map[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">sx = i, sy = j;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[i][j] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">ex = i, ey = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#S######.#</span></span><br><span class="line"><span class="comment">......#..#</span></span><br><span class="line"><span class="comment">.#.##.##.#</span></span><br><span class="line"><span class="comment">.#........</span></span><br><span class="line"><span class="comment">##.##.####</span></span><br><span class="line"><span class="comment">....#....#</span></span><br><span class="line"><span class="comment">.#######.#</span></span><br><span class="line"><span class="comment">....#.....</span></span><br><span class="line"><span class="comment">.####.###.</span></span><br><span class="line"><span class="comment">....#...G#</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="泉水"><a href="#泉水" class="headerlink" title="泉水"></a>泉水</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>Leyni是一个地址调查员，有一天在他调查的地方突然出现个泉眼。由于当地的地势不均匀，有高有低，他觉得如果这个泉眼不断的向外溶出水来，这意味着这里在不久的将来将会一个小湖。水往低处流，凡是比泉眼地势低或者等于的地方都会被水淹没，地势高的地方水不会越过。而且又因为泉水比较弱，当所有地势低的地方被淹没后，水位将不会上涨，一直定在跟泉眼一样的水位上。<br>  由于Leyni已经调查过当地很久了，所以他手中有这里地势的详细数据。所有的地图都是一个矩形，并按照坐标系分成了一个个小方格，Leyni知道每个方格的具体高度。我们假定当水留到地图边界时，不会留出地图外，现在他想通过这些数据分析出，将来这里将会出现一个多大面积的湖。</p></li><li><p>输入：有若干组数据，每组数据的第一行有四个整数n,m,p1,p2(0&lt;n,m,p1,p2&lt;=1000)，n和m表示当前地图的长和宽，p1和p2表示当前地图的泉眼位置，即第p1行第p2列，随后的n行中，每行有m个数据。表示这每一个对应坐标的高度。</p></li><li><p>输出：输出对应地图中会有多少个格子被水充满。</p><p>样例输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5 2 3</span><br><span class="line">3 4 1 5 1</span><br><span class="line">2 3 3 4 7</span><br><span class="line">4 1 4 1 1</span><br></pre></td></tr></table></figure><p>样例输出</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="原码-2"><a href="#原码-2" class="headerlink" title="原码"></a>原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n,p1,p2,sx, sy;</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    <span class="keyword">int</span>** MAP = <span class="keyword">new</span> <span class="keyword">int</span>* [n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        MAP[i] = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; MAP[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sx = p1 - <span class="number">1</span>;sy = p2 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;sx,sy&#125;);</span><br><span class="line">        vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> xx = t.first + dx[i];</span><br><span class="line">                <span class="keyword">int</span> yy = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(xx &gt;= <span class="number">0</span> &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; yy &lt;m &amp;&amp; MAP[xx][yy] &lt;= MAP[sx][sy] &amp;&amp; !vis[xx][yy])&#123;</span><br><span class="line">                    vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;xx,yy&#125;);</span><br><span class="line">                    ans ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="诡异的楼梯"><a href="#诡异的楼梯" class="headerlink" title="诡异的楼梯"></a>诡异的楼梯</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>Hogwarts正式开学以后,Harry发现在Hogwarts里,某些楼梯并不是静止不动的，相反,他们每隔一分钟就变动一次方向.<br>比如下面的例子里,一开始楼梯在竖直方向,一分钟以后它移动到了水平方向,再过一分钟它又回到了竖直方向.Harry发现对他来说很难找到能使得他最快到达目的地的路线,这时Ron(Harry最好的朋友)告诉Harry正好有一个魔法道具可以帮助他寻找这样的路线,而那个魔法道具上的咒语,正是由你纂写的.</li><li>输入：测试数据有多组，每组的表述如下：<br>第一行有两个数,M和N,接下来是一个M行N列的地图,’*’表示障碍物,’.’表示走廊,’|’或者’-‘表示一个楼梯,并且标明了它在一开始时所处的位置:’|’表示的楼梯在最开始是竖直方向,’-‘表示的楼梯在一开始是水平方向.地图中还有一个’S’是起点,’T’是目标,0&lt;=M,N&lt;=20,地图中不会出现两个相连的梯子.Harry每秒只能停留在’.’或’S’和’T’所标记的格子内.</li><li>输出：只有一行,包含一个数T,表示到达目标的最短时间.<br>注意:Harry只能每次走到相邻的格子而不能斜走,每移动一次恰好为一分钟,并且Harry登上楼梯并经过楼梯到达对面的整个过程只需要一分钟,Harry从来不在楼梯上停留.并且每次楼梯都恰好在Harry移动完毕以后才改变方向.</li></ul><p>样例输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">**..T</span><br><span class="line">**.*.</span><br><span class="line">..|..</span><br><span class="line">.*.*.</span><br><span class="line">S....</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="原码-3"><a href="#原码-3" class="headerlink" title="原码"></a>原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> map[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> sx, sy, ex, ey, lx, ly, hx, hy;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;; <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y, mins;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map[lx][ly] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    map[hx][hy] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now;</span><br><span class="line">now.x = sx; now.y = sy; now.mins = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(now);</span><br><span class="line">vis[now.x][now.y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">node nextt;</span><br><span class="line">nextt.x = t.x + dx[i]; nextt.y = t.y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nextt.x &gt;= <span class="number">0</span> &amp;&amp; nextt.x &lt; n &amp;&amp; nextt.y &gt;= <span class="number">0</span> &amp;&amp; nextt.y &lt; m &amp;&amp; !vis[nextt.x][nextt.y] &amp;&amp; map[nextt.x][nextt.y] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">nextt.mins = t.mins + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">change</span>();</span><br><span class="line"><span class="keyword">if</span>((i == <span class="number">1</span> || i == <span class="number">2</span>) &amp;&amp; map[nextt.x][nextt.y] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    nextt.mins--;</span><br><span class="line">                <span class="keyword">if</span>((i == <span class="number">3</span> || i == <span class="number">4</span>) &amp;&amp; map[nextt.x][nextt.y] == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">                    nextt.mins--;</span><br><span class="line"><span class="keyword">if</span>(nextt.x == ex &amp;&amp; nextt.y == ey)</span><br><span class="line">                    <span class="keyword">return</span> nextt.mins;</span><br><span class="line">                vis[nextt.x][nextt.y] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(nextt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, map[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">sx = i, sy = j;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[i][j] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">ex = i, ey = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (map[i][j] == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">                lx = i,ly = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (map[i][j] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                hx = i,hy = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="计算湖的个数"><a href="#计算湖的个数" class="headerlink" title="计算湖的个数"></a>计算湖的个数</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>由于最近的降雨，汇集在农民约翰农场的各个地方，由一个长方形的NxM（1==100；1==100）正方形表示。每个广场都包含水（“W”）或旱地（“.”）。农夫约翰想弄清楚在他的田地里形成了多少池塘。池塘是一组有水的连接正方形，其中一个正方形被认为是与它的八个邻居相邻的。给出一张农民约翰的田地的图，确定他有多少池塘。</li><li>输入：第1行：两个空间分隔的整数：N和M*第2行。N+1：每行M个字符代表农民约翰的一行字段。每个字符都是“W”或“。”。这些字符之间没有空格。</li><li>输出:第1行：农民约翰的田地里的池塘的数量。</li></ul><p>样例输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><p>样例输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="原码-4"><a href="#原码-4" class="headerlink" title="原码"></a>原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 101</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> sx = <span class="number">0</span>, sy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> MAP[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][j] == <span class="number">1</span>)</span><br><span class="line">                ans--;</span><br><span class="line">            <span class="keyword">if</span> (MAP[i][j] == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">                queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;sx,sy&#125;);</span><br><span class="line">                vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> xx = t.first + dx[i];</span><br><span class="line">                        <span class="keyword">int</span> yy = t.second + dy[i];</span><br><span class="line">                        <span class="keyword">if</span> (xx &gt;= <span class="number">0</span> &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; yy &lt; m &amp;&amp; !vis[xx][yy] &amp;&amp; MAP[xx][yy] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123; xx,yy &#125;);</span><br><span class="line">                            vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, MAP[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="红黑砖"><a href="#红黑砖" class="headerlink" title="红黑砖"></a>红黑砖</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>有一个长方形的房间，上面铺着正方形的瓷砖。每一块瓷砖都是红色或黑色的。一个男人站在一块黑瓷砖上。从一个瓷砖上，他可以移动到四个相邻的瓷砖之一。但他不能在红色瓷砖上移动，他只能在黑色瓷砖上移动。编写一个程序来计算他通过重复上述移动可以达到的黑色瓷砖的数量。</li><li>该输入内容由多个数据集组成。数据集以包含两个正整数W和H的直线开始；W和H分别是x方向和y方向上的块数。W和H的值不超过20个。在数据集中还有更多的行，每一个行都包含W个字符。每个字符都表示一个瓷砖的颜色，如下所示。‘.’-一个黑色瓷砖“#”-一个红色瓷砖“@”-一个黑色瓷砖上的人（恰好在数据集中中出现一次）输入的末端由两个零组成的行表示。</li><li>对于每个数据集，程序应输出一行，其中包含他从初始数据集可以到达的瓷砖数（包括它本身）。</li></ul><p>样例输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">45</span><br><span class="line">59</span><br><span class="line">6</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h3 id="原码-5"><a href="#原码-5" class="headerlink" title="原码"></a>原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 21</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> sx, sy;</span><br><span class="line"><span class="keyword">char</span> MAP[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;; <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;sx,sy&#125;);</span><br><span class="line">vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> xx = t.first + dx[i]; <span class="keyword">int</span> yy = t.second + dy[i];</span><br><span class="line"><span class="keyword">if</span> (xx &gt;= <span class="number">0</span> &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; yy &lt; m &amp;&amp; !vis[xx][yy] &amp;&amp; MAP[xx][yy] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; xx,yy &#125;);</span><br><span class="line">vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">ans ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; answer;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n*m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, MAP[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (MAP[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                    sx = i, sy = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        answer.<span class="built_in">push_back</span>(ans);</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; answer.<span class="built_in">size</span>();i ++)</span><br><span class="line">        cout &lt;&lt; answer[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="石油块种类"><a href="#石油块种类" class="headerlink" title="石油块种类"></a>石油块种类</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>地质勘测公司负责探测地下油床。地球冲浪委员会一次使用一个大的矩形土地区域，并创建了一个网格，将土地划分成许多方形地块。然后，它分别分析每个地块，使用传感设备来确定该地块是否含有油。一个含有油的地块被称为口袋。如果两个口袋相邻，那么它们是同一油矿床的一部分。石油沉积物可以相当大，并可能包含大量的口袋。你的工作是确定网格中包含多少不同的石油储量。</li><li>该输入包含一个或多个网格。每个网格以一条包含m和n的行开始，即网格中的行数和列数，由单个空格分隔。如果为=0，则发出输入结束信号；否则为1==100和1==100。下面是m行n个字符（不包括行尾字符）。每个字符对应于一个情节，或是’#’，表示没有油，或`@’，代表一个油口袋。</li><li>油口袋的油床大小为与水平、垂直或对角线相邻的油口袋之和。油藏不得超过100个口袋。</li></ul><p>样例输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">*</span><br><span class="line">3 5</span><br><span class="line">*@*@*</span><br><span class="line">**@**</span><br><span class="line">*@*@*</span><br><span class="line">1 8</span><br><span class="line">@@****@*</span><br><span class="line">5 5 </span><br><span class="line">****@</span><br><span class="line">*@@*@</span><br><span class="line">*@**@</span><br><span class="line">@@@*@</span><br><span class="line">@@**@</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="原码-6"><a href="#原码-6" class="headerlink" title="原码"></a>原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 21</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> sx, sy;</span><br><span class="line"><span class="keyword">char</span> MAP[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;; <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> vis[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;sx,sy&#125;);</span><br><span class="line">vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> xx = t.first + dx[i]; <span class="keyword">int</span> yy = t.second + dy[i];</span><br><span class="line"><span class="keyword">if</span> (xx &gt;= <span class="number">0</span> &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; yy &lt; m &amp;&amp; !vis[xx][yy] &amp;&amp; MAP[xx][yy] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; xx,yy &#125;);</span><br><span class="line">vis[xx][yy] = <span class="number">1</span>;</span><br><span class="line">ans ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; depos;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n*m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; answer;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, MAP[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (MAP[i][j] == <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    sx = i, sy = j;</span><br><span class="line">                    <span class="built_in">bfs</span>();</span><br><span class="line">                    answer.<span class="built_in">insert</span>(ans);</span><br><span class="line">                    ans = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depos.<span class="built_in">push_back</span>(answer.<span class="built_in">size</span>());</span><br><span class="line">        answer.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; depos.<span class="built_in">size</span>();i ++)</span><br><span class="line">        cout &lt;&lt; depos[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;输出“蛇形”矩阵&quot;&gt;&lt;a href=&quot;#输出“蛇形”矩阵&quot; class=&quot;headerlink&quot; title=&quot;输出“蛇形”矩阵&quot;&gt;&lt;/a&gt;输出“蛇形”矩阵&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从2-3-4树到红黑树</title>
    <link href="http://example.com/2021/04/27/%E4%BB%8E2-3-4%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2021/04/27/%E4%BB%8E2-3-4%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-04-27T13:25:04.000Z</published>
    <updated>2021-04-30T01:10:45.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从2-3-4树到红黑树"><a href="#从2-3-4树到红黑树" class="headerlink" title="从2-3-4树到红黑树"></a>从2-3-4树到红黑树</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从2-3-4树到红黑树&quot;&gt;&lt;a href=&quot;#从2-3-4树到红黑树&quot; class=&quot;headerlink&quot; title=&quot;从2-3-4树到红黑树&quot;&gt;&lt;/a&gt;从2-3-4树到红黑树&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AVL tree</title>
    <link href="http://example.com/2021/04/25/AVL-tree/"/>
    <id>http://example.com/2021/04/25/AVL-tree/</id>
    <published>2021-04-25T02:04:41.000Z</published>
    <updated>2021-05-12T22:55:58.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVL-TREE"><a href="#AVL-TREE" class="headerlink" title="AVL TREE"></a>AVL TREE</h1><span id="more"></span><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><pre><code>  平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），其本质还是平衡二叉树  且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li>插入</li><li>旋转</li><li>删除</li><li>查找</li></ul><h3 id="插入，删除，查找"><a href="#插入，删除，查找" class="headerlink" title="插入，删除，查找"></a>插入，删除，查找</h3><pre><code> 与二叉树类似</code></pre><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><img src="/2021/04/25/AVL-tree/01.png" class=""><img src="/2021/04/25/AVL-tree/02.png" class=""><img src="/2021/04/25/AVL-tree/03.png" class=""><img src="/2021/04/25/AVL-tree/04.png" class=""><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法）</span></span><br><span class="line"><span class="comment">  且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node * left;</span><br><span class="line">    node * right;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">AVL_TREE</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL_TREE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">node * <span class="title">Creat_BinarySearch_Tree</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Balance</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Delete</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    node * root;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">node * <span class="title">Getnewnode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Insert</span><span class="params">(node * root,<span class="keyword">int</span> data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Findheight</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getbalanceFactor</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">rightRotate</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">leftRotate</span><span class="params">(node * root)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">Findmin</span><span class="params">(node * root)</span></span>; <span class="comment">//后继节点</span></span><br><span class="line">    <span class="function">node * <span class="title">Delete_Element</span><span class="params">(node * root,<span class="keyword">int</span> element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Getnewnode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * newnode=(node *)<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    newnode-&gt;data=data;</span><br><span class="line">    newnode-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    newnode-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Insert</span><span class="params">(node *root,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        root=<span class="built_in">Getnewnode</span>(data);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;root-&gt;data)</span><br><span class="line">        root-&gt;left=<span class="built_in">Insert</span>(root-&gt;left,data);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;right=<span class="built_in">Insert</span>(root-&gt;right,data);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Creat_BinarySearch_Tree</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;How many numbers : &quot;</span>;</span><br><span class="line">    cin &gt;&gt; size;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Input the numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> *a_pointer=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a_pointer[i];</span><br><span class="line">        root=<span class="built_in">Insert</span>(root,a_pointer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AVL_TREE::Findheight</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Findheight</span>(root-&gt;right),<span class="built_in">Findheight</span>(root-&gt;left))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AVL_TREE::getbalanceFactor</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Findheight</span>(root-&gt;left)-<span class="built_in">Findheight</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::rightRotate</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * temp=root-&gt;left;</span><br><span class="line">    root-&gt;left=temp-&gt;right;</span><br><span class="line">    temp-&gt;right=root;</span><br><span class="line">    root=temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::leftRotate</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * temp=root-&gt;right;</span><br><span class="line">    root-&gt;right=temp-&gt;left;</span><br><span class="line">    temp-&gt;left=root;</span><br><span class="line">    root=temp;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Balance</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;left)&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//右旋LL</span></span><br><span class="line">root=<span class="built_in">rightRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &lt;<span class="number">-1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;right)&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//左旋RR</span></span><br><span class="line">root=<span class="built_in">leftRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LR</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;left) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">root-&gt;left = <span class="built_in">leftRotate</span>(root-&gt;left);</span><br><span class="line">root=<span class="built_in">rightRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RL</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getbalanceFactor</span>(root) &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">Findheight</span>(root-&gt;right)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">root-&gt;right = <span class="built_in">rightRotate</span>(root-&gt;right);</span><br><span class="line">        root=<span class="built_in">leftRotate</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Findmin</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Delete_Element</span><span class="params">(node * root,<span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element&lt;root-&gt;data)</span><br><span class="line">        root-&gt;left=<span class="built_in">Delete_Element</span>(root-&gt;left,element);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element&gt;root-&gt;data)</span><br><span class="line">        root-&gt;right=<span class="built_in">Delete_Element</span>(root-&gt;right,element);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//(root-&gt;left!=NULL&amp;&amp;root-&gt;right!=NULL)</span></span><br><span class="line">            &#123;</span><br><span class="line">            node * temp=<span class="built_in">Findmin</span>(root-&gt;right);</span><br><span class="line">            root-&gt;data=temp-&gt;data;</span><br><span class="line">            root-&gt;right=<span class="built_in">Delete_Element</span>(root-&gt;right,temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">AVL_TREE::Delete</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Which number to delete: &quot;</span> ;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line">        root=<span class="built_in">Delete_Element</span>(root,number);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Do you want to delete another element(Yes or no): &quot;</span>;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;n&#x27;</span>||ch==<span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::LevelOrder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root); <span class="comment">//Push the address of root</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node * current=Q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        Q.<span class="built_in">pop</span>(); <span class="comment">// Removing the element of front.</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Preorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Inorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Postorder</span><span class="params">(node * root)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AVL_TREE::Print</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LevelOrder traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;PreOrder traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">Preorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;InOrder traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Postorder traversal: &quot;</span> ;</span><br><span class="line">    <span class="built_in">Postorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The height of this tree is: &quot;</span>&lt;&lt; <span class="built_in">Findheight</span>(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The height of left tree is: &quot;</span>&lt;&lt;<span class="built_in">Findheight</span>(root-&gt;left) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The height of right tree is: &quot;</span>&lt;&lt;<span class="built_in">Findheight</span>(root-&gt;right) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVL_TREE t;</span><br><span class="line">    t.root=<span class="literal">NULL</span>;</span><br><span class="line">    t.root=t.<span class="built_in">Creat_BinarySearch_Tree</span>(t.root);</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line"></span><br><span class="line">    t.root=t.<span class="built_in">Balance</span>(t.root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;After rotation: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line"></span><br><span class="line">    t.root=t.<span class="built_in">Delete</span>(t.root);</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line"></span><br><span class="line">    t.root=t.<span class="built_in">Balance</span>(t.root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;After rotation: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">Print</span>(t.root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AVL-TREE&quot;&gt;&lt;a href=&quot;#AVL-TREE&quot; class=&quot;headerlink&quot; title=&quot;AVL TREE&quot;&gt;&lt;/a&gt;AVL TREE&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Counting sort （计数排序）</title>
    <link href="http://example.com/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>http://example.com/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/</id>
    <published>2021-04-24T13:33:35.000Z</published>
    <updated>2021-04-24T15:21:59.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Counting-sort"><a href="#Counting-sort" class="headerlink" title="Counting sort"></a>Counting sort</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>  计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）</code></pre><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>找出原数组的最大值，记为max</li><li>创建一个新数组count ，其长度是max+1 ，其元素默认值都是一</li><li>遍历原数组的元素，原数组的元素值作为count数组的下标，原数组的元素出现的次数作为count数组的元素值</li><li>创建一个新数组result，长度为原数组的长度</li><li>遍历count数组，其中大于0的元素的下标值作为result数组的元素值，没一次count中该元素值减一，直到该元素等于0</li><li>打印数组result</li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/01.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/02.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/03.png" class=""><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 找出数组A中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmax</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;arr[i])</span><br><span class="line">           max=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmin</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min&gt;arr[i])</span><br><span class="line">            min=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Countsort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="built_in">Findmax</span>(arr,len);</span><br><span class="line">    <span class="comment">// 初始化计数数组count</span></span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max+<span class="number">1</span>;i++)</span><br><span class="line">        count[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对计数数组各元素赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    <span class="comment">// 创建结果数组并初始化</span></span><br><span class="line">    <span class="keyword">int</span> *result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        result[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建结果数组的起始索引</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历计数数组，将计数数组的索引填充到结果数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            result[index++]=i;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印结果数组</span></span><br><span class="line">    <span class="built_in">print</span>(result,len);</span><br><span class="line">     <span class="keyword">delete</span> [] count;</span><br><span class="line">     <span class="keyword">delete</span> [] result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">Countsort</span>(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code>  基础版能够解决一般的情况，但是它有一个缺陷，那就是存在空间浪费的问题。  比如一组数据&#123;101,109,108,102,110,107,103&#125;，其中最大值为110，按照基础版的思路，我们需要创建一个长度为111的计数数组，但是我们可以发现，它前面的[0,100]的空间完全浪费了，那怎样优化呢？  将数组长度定为max-min+1，即不仅要找出最大值，还要找出最小值，根据两者的差来确定计数数组的长度。</code></pre><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ul><li>找出原数组的最大值max，最小值min</li><li>创建一个count数组，其大小为max-min+1,并初始化所有元素为0</li><li>遍历原数组的元素，原数组的元素值减去min作为count数组的下标，原数组的元素出现的次数作为count数组的元素值</li><li>创建一个新数组result，长度为原数组的长度</li><li>遍历count数组，其中大于0的元素的下标值加上min作为result数组的元素值，每一次count中该元素值减一，直到该元素等于0</li><li>打印result数组</li></ul><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/04.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/05.png" class=""><img src="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/06.png" class=""><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 找出数组arr中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmax</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;arr[i])</span><br><span class="line">           max=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出数组arr的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findmin</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min&gt;arr[i])</span><br><span class="line">            min=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Countsort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min=<span class="built_in">Findmin</span>(arr,len);</span><br><span class="line">    <span class="keyword">int</span> max=<span class="built_in">Findmax</span>(arr,len);</span><br><span class="line">    <span class="keyword">int</span> x=max-min+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化计数数组count</span></span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">        count[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="comment">// A中的元素要减去最小值，再作为新索引</span></span><br><span class="line">        count[arr[i]-<span class="built_in">Findmin</span>(arr,len)]++;</span><br><span class="line">     <span class="comment">// 创建结果数组并初始化</span></span><br><span class="line">    <span class="keyword">int</span> *result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        result[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 遍历计数数组，将计数数组的索引填充到结果数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 再将减去的最小值补上</span></span><br><span class="line">            result[index++]=i+min;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(result,len);</span><br><span class="line">    <span class="keyword">delete</span> [] count;</span><br><span class="line">    <span class="keyword">delete</span> [] result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>]=&#123;<span class="number">101</span>,<span class="number">109</span>,<span class="number">107</span>,<span class="number">103</span>,<span class="number">108</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">110</span>,<span class="number">107</span>,<span class="number">103</span>&#125;;</span><br><span class="line">    <span class="built_in">Countsort</span>(b,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><pre><code>  计数排序虽然它可以将排序算法的时间复杂度降低到O(N)，但是有两个前提需要满足：一是需要排序的元素必须是整数，二是排序元素的取值要在一定范围内，并且比较集中。只有这两个条件都满足，才能最大程度发挥计数排序的优势。</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xiaochuan94/p/11198610.html">博客园</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Counting-sort&quot;&gt;&lt;a href=&quot;#Counting-sort&quot; class=&quot;headerlink&quot; title=&quot;Counting sort&quot;&gt;&lt;/a&gt;Counting sort&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BinarySort</title>
    <link href="http://example.com/2021/04/23/BinarySort/"/>
    <id>http://example.com/2021/04/23/BinarySort/</id>
    <published>2021-04-23T07:42:24.000Z</published>
    <updated>2021-04-23T08:20:10.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BinarySort"><a href="#BinarySort" class="headerlink" title="BinarySort"></a>BinarySort</h1><span id="more"></span><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre><code>  二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用，而且表中元素按关键字有序排列</code></pre><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><pre><code>        首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功</code></pre><h3 id="算法要求"><a href="#算法要求" class="headerlink" title="算法要求"></a>算法要求</h3><ul><li><p>必须采用<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">顺序存储结构</a></p></li><li><p>必须按关键字大小有序排列</p></li></ul><h3 id="比较次数"><a href="#比较次数" class="headerlink" title="比较次数"></a>比较次数</h3><img src="/2021/04/23/BinarySort/01.png" class=""><pre><code>  当顺序表有n个关键字时： 查找失败时，至少比较a次关键字； 查找成功时，最多比较关键字次数是b 注意：a,b,n均为正整数</code></pre><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><pre><code>  二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x.  时间复杂度即是while循环的次数。  总共有n个元素，  渐渐跟下去就是n,n/2,n/4,....n/2^k（接下来操作元素的剩余个  数），其中k就是循环的次数  由于你n/2^k取整后&gt;=1  即令n/2^k=1  可得k=log2n,（是以2为底，n的对数）  所以时间复杂度可以表示O(h)=O(log2n)</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid]==value)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value&gt;arr[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinarySearch1</span>(arr,mid+<span class="number">1</span>,high,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinarySearch1</span>(arr,low,mid<span class="number">-1</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(high+low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(value==arr[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;arr[mid])</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><pre><code>   插入排序是指在待排序的元素中，假设前面n-1(其中n&gt;=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序</code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><pre><code>时间复杂度：   在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(N)   最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为 O(N^2)   平均来说，A[1..j-1]中的一半元素小于A[j]，一半元素大于A[j]。插入排序在平均情况运行时间与最坏情况运行时间一样，是输入规模的二次函数 空间复杂度：  插入排序的空间复杂度为常数阶O(1)</code></pre><h3 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h3><pre><code>  如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code>  插入排序适用于已经有部分数据已经排好，并且排好的部分越大越好。一般在输入规模大于1000的场合下不建议使用插入排序</code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StraightSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp;j--)</span><br><span class="line">&#123;</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><pre><code>  二分法插入排序，简称二分排序，是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上</code></pre><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><pre><code>  二分插入排序是稳定的与二分查找的复杂度相同； 最好的情况是当插入的位置刚好是二分位置 所用时间为O(log₂n);最坏的情况是当插入的位置不在二分位置 所需比较次数为O(n)平均时间O(n^2)</code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binsert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,left,right,mid,x;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        x=a[i];</span><br><span class="line">        left=<span class="number">0</span>;right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x&gt;a[mid]) &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=i<span class="number">-1</span>; j&gt;=left; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BinarySort&quot;&gt;&lt;a href=&quot;#BinarySort&quot; class=&quot;headerlink&quot; title=&quot;BinarySort&quot;&gt;&lt;/a&gt;BinarySort&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Binary search tree</title>
    <link href="http://example.com/2021/04/20/Binary-search-tree/"/>
    <id>http://example.com/2021/04/20/Binary-search-tree/</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2021-04-20T16:01:27.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-search-tree"><a href="#Binary-search-tree" class="headerlink" title="Binary search tree"></a>Binary search tree</h1><span id="more"></span><h2 id="Implementation-in-c-c"><a href="#Implementation-in-c-c" class="headerlink" title="Implementation in c/c++"></a>Implementation in c/c++</h2><pre><code>        最流行的方式是动态的创造节点并用指针把它们链接起来</code></pre><img src="/2021/04/20/Binary-search-tree/01.png" class=""><pre><code>        实现方式：使用递归的方式创造如下图的节点</code></pre><img src="/2021/04/20/Binary-search-tree/02.png" class=""><h3 id="Use-struct-to-create-a-node"><a href="#Use-struct-to-create-a-node" class="headerlink" title="Use struct to create a node"></a>Use struct to create a node</h3><pre><code>        c语言中通过malloc函数或者c++中通过new运算符在堆区(heap)创造节点</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    node * left;   </span><br><span class="line">    node * right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2021/04/20/Binary-search-tree/03.png" class=""><h3 id="Use-function-to-create-a-new-node-in-heap"><a href="#Use-function-to-create-a-new-node-in-heap" class="headerlink" title="Use function to create a new node in heap"></a>Use function to create a new node in heap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node * <span class="title">Getnewnode</span><span class="params">(<span class="keyword">int</span> date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node * newnode=<span class="keyword">new</span> node;</span><br><span class="line">    newnode-&gt;date=date;  </span><br><span class="line">    newnode-&gt;left=<span class="literal">NULL</span>;  </span><br><span class="line">    newnode-&gt;right=<span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> newnode;   <span class="comment">//如果root定义为全局变量，则此处可以为 root=newnode; return root;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Create-a-tree"><a href="#Create-a-tree" class="headerlink" title="Create a tree"></a>Create a tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">node * <span class="title">Insert</span><span class="params">(node * root,<span class="keyword">int</span> date)</span>  <span class="comment">//返回root的地址，主函数需要更新此地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;   <span class="comment">//递归</span></span><br><span class="line">        root=<span class="built_in">Getnewnode</span>(date);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(date&lt;root-&gt;date)&#123;</span><br><span class="line">        root-&gt;left=<span class="built_in">Insert</span>(root-&gt;left,date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        root-&gt;right=<span class="built_in">Insert</span>(root-&gt;right,date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node * root=<span class="literal">NULL</span>;</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">15</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">10</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">20</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">18</span>);</span><br><span class="line">    root=<span class="built_in">Insert</span>(root,<span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Search-whether-it-exists"><a href="#Search-whether-it-exists" class="headerlink" title="Search whether it exists"></a>Search whether it exists</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool Search(node * root,int date)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return false;</span><br><span class="line">    if(date&#x3D;&#x3D;root-&gt;date)</span><br><span class="line">        return true;</span><br><span class="line">    else if(date&lt;root-&gt;date)</span><br><span class="line">         Search(root-&gt;left,date);</span><br><span class="line">    else</span><br><span class="line">         Search(root-&gt;right,date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Find-min-and-max-element-of-BST"><a href="#Find-min-and-max-element-of-BST" class="headerlink" title="Find min and max element of BST"></a>Find min and max element of BST</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMin</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMax</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Delete-a-node"><a href="#Delete-a-node" class="headerlink" title="Delete a node"></a>Delete a node</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node * <span class="title">Findmin</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">//返回该节点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">node * Findmax(node * root)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(root==NULL)</span></span><br><span class="line"><span class="comment">    return NULL;</span></span><br><span class="line"><span class="comment">while(root-&gt;right!)</span></span><br><span class="line"><span class="comment"> root=root-&gt;right;</span></span><br><span class="line"><span class="comment">return root;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">node * <span class="title">Delete</span><span class="params">(node * root,<span class="keyword">int</span> date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(date&lt;root-&gt;date)</span><br><span class="line">        root-&gt;left=<span class="built_in">Delete</span>(root-&gt;left,date);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(date&gt;root-&gt;date)</span><br><span class="line">        root-&gt;right=<span class="built_in">Delete</span>(root-&gt;right,date);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=<span class="literal">NULL</span>;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            node * temp=root;</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//(root-&gt;left!=NULL&amp;&amp;root-&gt;right!=NULL)</span></span><br><span class="line">            &#123;  temp指向左子树的最大值或者右子树的最小值</span><br><span class="line">            node * temp=<span class="built_in">Findmin</span>(root-&gt;right);        <span class="comment">//node * temp=Findmax(root-&gt;left);</span></span><br><span class="line">            root-&gt;date=temp-&gt;date;                   <span class="comment">//root-&gt;date=temp-&gt;date;</span></span><br><span class="line">            root-&gt;right=<span class="built_in">Delete</span>(root-&gt;right,temp-&gt;date);<span class="comment">//root-&gt;left=Delete(root-&gt;left,temp-&gt;date);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Binary-Tree-Traversal"><a href="#Binary-Tree-Traversal" class="headerlink" title="Binary Tree Traversal"></a>Binary Tree Traversal</h2><h3 id="Level-Order-Traversal-By-Queue-（广度优先遍历）"><a href="#Level-Order-Traversal-By-Queue-（广度优先遍历）" class="headerlink" title="Level-Order Traversal By Queue （广度优先遍历）"></a>Level-Order Traversal By Queue （广度优先遍历）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span>  <span class="comment">//包含队列的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No node: &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node * current=Q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; current-&gt;date &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preorder-Inorder-Postorder（深度优先遍历）"><a href="#Preorder-Inorder-Postorder（深度优先遍历）" class="headerlink" title="Preorder,Inorder,Postorder（深度优先遍历）"></a>Preorder,Inorder,Postorder（深度优先遍历）</h3><ul><li>遍历顺序：</li></ul><img src="/2021/04/20/Binary-search-tree/04.png" class=""><ul><li>Preorder (前序遍历)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line"><span class="built_in">Preorder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line"><span class="built_in">Preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// F D B A C E J G I K</span></span><br></pre></td></tr></table></figure><p>栈区调用图解：</p><img src="/2021/04/20/Binary-search-tree/05.png" class=""><ul><li>Inorder（中序遍历）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">Inorder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line"><span class="built_in">Inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A B C D E F G H I J K</span></span><br></pre></td></tr></table></figure><ul><li>Postorder（后序遍历）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">Postorder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">Postorder</span>(root-&gt;right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;date);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// A C B E D I G K J F</span></span><br></pre></td></tr></table></figure><h2 id="Find-height-of-a-binary-tree"><a href="#Find-height-of-a-binary-tree" class="headerlink" title="Find height of a binary tree"></a>Find height of a binary tree</h2><img src="/2021/04/20/Binary-search-tree/06.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findheight</span><span class="params">(node * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Findheight</span>(root-&gt;right),<span class="built_in">Findheight</span>(root-&gt;left))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Complete-code"><a href="#Complete-code" class="headerlink" title="Complete code"></a>Complete code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int date;</span><br><span class="line">    node * left;</span><br><span class="line">    node * right;</span><br><span class="line">&#125;;</span><br><span class="line">node * Getnewnode(int date)</span><br><span class="line">&#123;</span><br><span class="line">    node * newnode&#x3D;(node *)new node();</span><br><span class="line">    newnode-&gt;date&#x3D;date;</span><br><span class="line">    newnode-&gt;left&#x3D;NULL;</span><br><span class="line">    newnode-&gt;right&#x3D;NULL;</span><br><span class="line">    return newnode;</span><br><span class="line">&#125;</span><br><span class="line">node * Insert(node *root,int date)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;Getnewnode(date);</span><br><span class="line">    else if(date&lt;root-&gt;date)</span><br><span class="line">        root-&gt;left&#x3D;Insert(root-&gt;left,date);</span><br><span class="line">    else</span><br><span class="line">        root-&gt;right&#x3D;Insert(root-&gt;right,date);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">int FindMin(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    while(root-&gt;left!&#x3D;NULL)</span><br><span class="line">        root&#x3D;root-&gt;left;</span><br><span class="line">    return root-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line">int FindMax(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    while(root-&gt;right!&#x3D;NULL)</span><br><span class="line">        root&#x3D;root-&gt;right;</span><br><span class="line">    return root-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line">node * Findmin(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    while(root-&gt;left!&#x3D;NULL)&#123;</span><br><span class="line">        root&#x3D;root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">node * Delete(node * root,int date)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    else if(date&lt;root-&gt;date)</span><br><span class="line">        root-&gt;left&#x3D;Delete(root-&gt;left,date);</span><br><span class="line">    else if(date&gt;root-&gt;date)</span><br><span class="line">        root-&gt;right&#x3D;Delete(root-&gt;right,date);</span><br><span class="line">    else&#123;</span><br><span class="line">        if(root-&gt;left&#x3D;&#x3D;NULL&amp;&amp;root-&gt;right&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">            node * temp&#x3D;root;</span><br><span class="line">            root&#x3D;NULL;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;left&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">            node * temp&#x3D;NULL;</span><br><span class="line">            root&#x3D;root-&gt;right;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;right&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">            node * temp&#x3D;root;</span><br><span class="line">            root&#x3D;root-&gt;left;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#x2F;&#x2F;(root-&gt;left!&#x3D;NULL&amp;&amp;root-&gt;right!&#x3D;NULL)</span><br><span class="line">            &#123;</span><br><span class="line">            node * temp&#x3D;Findmin(root-&gt;right);</span><br><span class="line">            root-&gt;date&#x3D;temp-&gt;date;</span><br><span class="line">            root-&gt;right&#x3D;Delete(root-&gt;right,temp-&gt;date);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Findheight(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    return max(Findheight(root-&gt;right),Findheight(root-&gt;left))+1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;前序遍历</span><br><span class="line">void Preorder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL) return;</span><br><span class="line">    printf(&quot;%d &quot;,root-&gt;date);</span><br><span class="line">    Preorder(root-&gt;left);</span><br><span class="line">    Preorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">void Inorder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL) return;</span><br><span class="line">    Inorder(root-&gt;left);</span><br><span class="line">    printf(&quot;%d &quot;,root-&gt;date);</span><br><span class="line">    Inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;后序遍历</span><br><span class="line">void Postorder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL) return;</span><br><span class="line">    Postorder(root-&gt;left);</span><br><span class="line">    Postorder(root-&gt;right);</span><br><span class="line">    printf(&quot;%d &quot;,root-&gt;date);</span><br><span class="line">&#125;</span><br><span class="line">void LevelOrder(node * root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;No node: &quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;node *&gt; Q;</span><br><span class="line">    Q.push(root);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        node * current&#x3D;Q.front();</span><br><span class="line">        cout &lt;&lt; current-&gt;date &lt;&lt; &quot; &quot;;</span><br><span class="line">        if(current-&gt;left!&#x3D;NULL)</span><br><span class="line">            Q.push(current-&gt;left);</span><br><span class="line">        if(current-&gt;right!&#x3D;NULL)</span><br><span class="line">            Q.push(current-&gt;right);</span><br><span class="line">        Q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    node * root&#x3D;NULL;</span><br><span class="line">    root&#x3D;Insert(root,15);</span><br><span class="line">    Insert(root,10);</span><br><span class="line">    Insert(root,20);</span><br><span class="line">    Insert(root,7);</span><br><span class="line">    Insert(root,13);</span><br><span class="line">    Insert(root,18);</span><br><span class="line">    Insert(root,22);</span><br><span class="line">    Insert(root,5);</span><br><span class="line">    Insert(root,9);</span><br><span class="line">    Insert(root,11);</span><br><span class="line">    Insert(root,14);</span><br><span class="line">    cout &lt;&lt; &quot;LevelOrder: &quot;;</span><br><span class="line">    LevelOrder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Preorder: &quot;;</span><br><span class="line">    Preorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Inorder: &quot;;</span><br><span class="line">    Inorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Postorder: &quot;;</span><br><span class="line">    Postorder(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The min of this tree is &quot; &lt;&lt; FindMin(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;the max of this tree is &quot; &lt;&lt; FindMax(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The height of this tree is &quot; &lt;&lt; Findheight(root) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    int number;</span><br><span class="line">    cout &lt;&lt; &quot;Which number to delete: &quot;;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line">    root&#x3D;Delete(root,number);</span><br><span class="line">    cout &lt;&lt; &quot;After delete : &quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;LevelOrder: &quot;;</span><br><span class="line">    LevelOrder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Preorder: &quot;;</span><br><span class="line">    Preorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Inorder: &quot;;</span><br><span class="line">    Inorder(root);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;Postorder: &quot;;</span><br><span class="line">    Postorder(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The min of this tree is &quot; &lt;&lt; FindMin(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;the max of this tree is &quot; &lt;&lt; FindMax(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The height of this tree is &quot; &lt;&lt; Findheight(root) &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Binary-search-tree&quot;&gt;&lt;a href=&quot;#Binary-search-tree&quot; class=&quot;headerlink&quot; title=&quot;Binary search tree&quot;&gt;&lt;/a&gt;Binary search tree&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Introduction to Trees</title>
    <link href="http://example.com/2021/04/20/Introduction-to-trees/"/>
    <id>http://example.com/2021/04/20/Introduction-to-trees/</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2021-04-20T12:06:15.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-Trees"><a href="#Introduction-to-Trees" class="headerlink" title="Introduction to Trees"></a>Introduction to Trees</h1><span id="more"></span><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>  树是一种数据结构，树（tree）是包含n(n&gt;=1)个节点，(n-1)条边的有穷集<br>  树也可以这样定义：树是由根节点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的节点，所定义的关系称为父子关系。父子关系在树的节点之间建立了一个层次结构。在这种层次结构中有一个节点具有特殊的地位，这个节点称为该树的根节点，或称为树根 其中：</p><ol><li>每个节点有零个或多个子节点；</li><li> 没有父节点的节点称为根节点；</li><li> 每一个非根节点有且只有一个父节点；</li><li> 除了根节点外，每个子节点可以分为多个不相交的子树。</li></ol><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p>节点：构造树的基本单位<br>树的深度：从根节点到叶子结点路径的最大边数<br>树的高度：从根节点到给节点的边数<br>结点的度：结点拥有的子树的数目<br>叶子：度为零的结点<br>分支结点：度不为零的结点<br>树的度：树中结点的最大的度</p><h3 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h3><p>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树<br>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树<br>二叉树：每个节点最多含有两个子树的树称为二叉树<br>满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树<br>完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树<br>二叉查找树：（二叉搜索树 二叉排序树）一棵空树，或者是有序的二叉树，且没有键值相等的节点<br>AVL 树：根节点的左子树与右子树的高度只差的绝对值小于2的二叉查找树<br>红黑树：红黑树（Red Black Tree） 是一种自平衡二叉查找树<br>哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树</p><h2 id="二叉树的介绍"><a href="#二叉树的介绍" class="headerlink" title="二叉树的介绍"></a>二叉树的介绍</h2><p>二叉树是每个节点最多有两个子树的树结构。它具有五种基本形态<br>1、空二叉树<br>2、只有一个根结点的二叉树<br>3、只有左子树<br>4、只有右子树<br>5、完全二叉树</p><h3 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h3><ol><li>二叉树的第i层上至多有2i-1（i≥1）个节点 </li><li>深度为h的二叉树中至多含有2h-1个节点 </li><li>若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0=n2+1 </li><li>具有n个节点的完全二叉树深为log2x+1（其中x表示不大于n的最大整数）</li></ol><h3 id="满二叉树（完美二叉树）"><a href="#满二叉树（完美二叉树）" class="headerlink" title="满二叉树（完美二叉树）"></a>满二叉树（完美二叉树）</h3><p>定义：高度为h，并且由2{h+1}-1个结点的二叉树，被称为满二叉树</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。<br>特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树</p><img src="/2021/04/20/Introduction-to-trees/03.png" class=""><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>定义：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]</p><p>在二叉查找树中：</p><ol><li><p>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p></li><li><p>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p></li><li><p>任意节点的左、右子树也分别为二叉查找树</p></li><li><p> 没有键值相等的节点（no duplicate nodes）</p></li></ol><p>产生二叉树的原因：有二分的思想，对比数组链表，插入删除，查找的平均时间复杂度更低</p><img src="/2021/04/20/Introduction-to-trees/06.png" class=""><img src="/2021/04/20/Introduction-to-trees/04.png" class=""><h3 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h3><p>定义：AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1 即（|Height(Lefttree)-Height(Righttree)|&lt;=1）因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡</p><p>**AVL树本质上还是一棵二叉搜索树，它的特点是： **</p><ol><li><p>本身首先是一棵二叉搜索树。</p></li><li><p>带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1</p></li></ol><p>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）</p><p>产生原因：对二叉查找树的优化</p><img src="/2021/04/20/Introduction-to-trees/05.png" class=""><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>定义：R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)</p><p><strong>红黑树的特性</strong>:</p><ol><li>每个节点或者是黑色，或者是红色</li><li>根节点是黑色</li><li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点</li><li>如果一个节点是红色的，则它的子节点必须是黑色的</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li></ol><p> 示意图如下</p><img src="/2021/04/20/Introduction-to-trees/01.jpg" class=""><p><strong>对比avl树：</strong>首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。<strong>所以红黑树的插入效率更高</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Introduction-to-Trees&quot;&gt;&lt;a href=&quot;#Introduction-to-Trees&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Trees&quot;&gt;&lt;/a&gt;Introduction to Trees&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

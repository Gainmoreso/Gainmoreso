<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>graphs | Hexo</title><meta name="author" content="AlbertH"><meta name="copyright" content="AlbertH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="graphs">
<meta property="og:type" content="article">
<meta property="og:title" content="graphs">
<meta property="og:url" content="http://example.com/2021/07/18/graphs/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="graphs">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-07-17T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-26T15:22:29.253Z">
<meta property="article:author" content="AlbertH">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/18/graphs/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-26 23:22:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">graphs</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-17T16:00:00.000Z" title="发表于 2021-07-18 00:00:00">2021-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-26T15:22:29.253Z" title="更新于 2021-07-26 23:22:29">2021-07-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="graphs"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="graphs"><a href="#graphs" class="headerlink" title="graphs"></a>graphs</h1><span id="more"></span>

<h2 id="图的基本介绍"><a href="#图的基本介绍" class="headerlink" title="图的基本介绍"></a>图的基本介绍</h2><h2 id="图的基本属性"><a href="#图的基本属性" class="headerlink" title="图的基本属性"></a>图的基本属性</h2><h2 id="图的表示法"><a href="#图的表示法" class="headerlink" title="图的表示法"></a>图的表示法</h2><h3 id="边列表"><a href="#边列表" class="headerlink" title="边列表"></a>边列表</h3><ul>
<li>一个图包含了一组顶点和一组边 数学定义为G = (V , E) ，我们可以创建两个列表，一个来存储所有的顶点，另一个来存储所有的边，对于列表，可以用数组实现，也可以用库函数提供的动态列表来实现，如c++中的vector，或者java中的arraylist</li>
</ul>
<img src="/2021/07/18/graphs/01.png" class="">

<ul>
<li><p>如图为一个有权重的无向图。第一个列表包含顶点，将会是一个名字列表或字符串列表，第二个列表包含边，边是由两个端点标识的，可以将边作为一个对象，它由三个域组成，起始节点和终止节点和权重，因此可以定义为结构体。</p>
</li>
<li><p>C语言中可以使用struct结构体，用字符指针保存对字符串的引用，c++中可以用class类，使用string </p>
</li>
<li><p>一个更好的设计是使用名字或字符串在顶点列表中的索引,如下图所示</p>
</li>
</ul>
<img src="/2021/07/18/graphs/02.png" class="">

<ul>
<li><p>无论使用什么方式存储都应该考虑它的复杂度。</p>
</li>
<li><p>考虑空间复杂度，两个列表都是线性的，每一行使用的内存量是一样的，将正比于边数和顶点数，因此空间复杂度为O(|V| + |E|).存图来说，算可以的了。</p>
</li>
<li><p>考虑时间复杂度，对图最频繁的操作无非是找到一个节点所有相邻的节点，我们将扫描整个边列表，进行线性查找，时间复杂度为O(|E|)。另一个频繁的操作是判断给定的两个节点是否相连，也将进行线性查找，最坏的情况是和边的数量成正比，时间复杂度为O(|E|).</p>
</li>
<li><p>评价时间复杂度的好坏 ，最坏的情况对于稠密的图，边的数量总是接近顶点数的平方。因此O(|E|) = O(|V^2|).以边为阶数的查找或判断操作，这是耗时的。</p>
</li>
</ul>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ul>
<li><p>考虑到边列表时间复杂度为O(|V^2|)，产生了一种设计，使用二维数组或者二维矩阵。把边或者链接存储在矩阵或二维数组的形式被称作为邻接矩阵（adjacency matrix）</p>
</li>
<li><p>可以将二维数组设为bool型，0表示对应节点没有连接，1表示连接。实际上，当查找两个节点是否连接，通过扫描找到索引，只用遍历一半二维数组，因为a[i] [j]  = a[j] [i] ，是对称的。</p>
</li>
</ul>
<img src="/2021/07/18/graphs/05.png" class="">

<ul>
<li><p>考虑时间复杂度，想要查找一个节点的所有相邻节点，需要扫描vertex，找到对应的行，然后再扫描该行来找到邻居，最坏的情况是要扫描整个列表，时间复杂度为O(V) ;想要知道两个节点是否相连，如果知道索引，我们只需要通过索引，在常数时间内找到a[i] [j] ，这个操作的时间复杂度为0(1).如果知道名字，我们需要通过名字找到索引，这将花费O(V).总的时间成本是O(V)</p>
</li>
<li><p>为了找到索引总是需要扫描列表，这是可以避免的。我们可以使用额外的内存来创建一个哈希表，把名字和索引作为键值对来保存，那么从名字找到索引的时间将会变成O(1)</p>
</li>
</ul>
<img src="/2021/07/18/graphs/03.png" class="">

<ul>
<li>如果我们要存一个有权重的图（如下图所示），可以将a[i] [j] 的值设为该条边的权重，对于不存在的边，设为一个默认值，比如很大的值（达不到的权重值）</li>
</ul>
<img src="/2021/07/18/graphs/04.png" class="">

<ul>
<li>考虑空间复杂度。如果一个图是稀疏的（例如,互联网，社交网络，每个用户相当于节点，每个用户的朋友关系相当于边，节点可以有数十亿多个，边却很少），如果要存这样一个图，则会花费很大的空间开二维数组 ，存很多的0.空间复杂度为O（V^2）这是不划算的。</li>
<li>因此，邻接矩阵对稠密的图是友好的，但稀疏的会造成空间的浪费，实际上，世界上大部分的图都是稀疏的。下图为一个稀疏的图的存储信息的内存消耗对比</li>
</ul>
<img src="/2021/07/18/graphs/07.png" class="">

<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul>
<li>对于邻接矩阵，它的每一行都存储着相应节点的边的信息，我们可以知道该节点与哪些相连（1表示），与哪些不相连（0表示）。每一行都是一个大小固定的为节点数的一维数组。</li>
</ul>
<img src="/2021/07/18/graphs/06.png" class="">

<ul>
<li>为了存储节点的连接，解决0的冗余，可以不使用数组，我们可以直接保存一个所有连接节点的列表，该表就被成为邻接表（如下图所示）</li>
</ul>
<img src="/2021/07/18/graphs/08.png" class="">

<ul>
<li><p>如果要查找两个节点是否连接，采用上图的存储方式，需要通过其中一个节点的索引在邻接表中进行线性查找，在最坏的情况下，时间复杂度为O(|V|)，即该节点与其他所有节点相连，当然，如果采用二分查找，将会为O(|Log V|)</p>
</li>
<li><p>如果要查找一个节点的所有邻居，时间复杂度为O(|V|)</p>
</li>
</ul>
<img src="/2021/07/18/graphs/09.png" class="">

<ul>
<li>邻接矩阵牺牲空间，换取时间，邻接表牺牲时间换取空间，到底应该如何选取呢，下图的例子可以说明</li>
</ul>
<img src="/2021/07/18/graphs/10.png" class="">

<ul>
<li>考虑对图的一些操作。如果要添加或删除一条边，对于邻接矩阵来说，只需要找到对应两个节点索引的二维数组矩阵，将标记变为0或1即可，对于邻接表，由于不能动态增加一个已知数组的大小，我们需要创建一个更大的数组，将原数组拷贝到新数组，再释放原数组。这将是很麻烦的事，因此采用链表或二叉树来存储动态列表是更好的选择（如下图链表实现的列表）</li>
</ul>
<img src="/2021/07/18/graphs/11.png" class="">

<ul>
<li>我们需要为每一个节点创建一个链表，存储它相邻的所有节点，空间的消耗正比于边的个数，即链表的长度，即O(|E|)，|E|&lt;&lt;|V|*|V|(大多数)</li>
<li>考虑邻接表的弹性，假如要添加或删除一条边，效率上来说，用树结构代替链表会有提高的</li>
</ul>
<h2 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><h3 id="有向图原码"><a href="#有向图原码" class="headerlink" title="有向图原码"></a>有向图原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string data[N];		   <span class="comment">//节点名称</span></span><br><span class="line">    <span class="keyword">bool</span> vis[N][N] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//标记是否存在这样的边</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;    <span class="comment">//图的当前顶点数和边</span></span><br><span class="line">    <span class="keyword">int</span> value[N][N];       <span class="comment">//边的权重</span></span><br><span class="line">&#125; AdjGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_graph</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.arcnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, value;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; value;</span><br><span class="line">        G.vis[a][b] = <span class="number">1</span>;</span><br><span class="line">        G.value[a][b] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; G.data[i] &lt;&lt; <span class="string">&quot;的邻居有:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;=G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.vis[i][j] == <span class="number">1</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; G.data[j] &lt;&lt; <span class="string">&quot; 权重:&quot;</span>&lt;&lt; G.value[i][j] &lt;&lt; <span class="string">&quot;&#125;&quot;</span>&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjGraph G;</span><br><span class="line">    <span class="built_in">create_graph</span>(G);</span><br><span class="line">    <span class="built_in">print</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试样例:</span></span><br><span class="line"><span class="comment">9 11</span></span><br><span class="line"><span class="comment">C1 C2 C3 C4 C5 C6 C7 C8 C9</span></span><br><span class="line"><span class="comment">1 3 10</span></span><br><span class="line"><span class="comment">1 8 15</span></span><br><span class="line"><span class="comment">2 3 20</span></span><br><span class="line"><span class="comment">2 4 35 </span></span><br><span class="line"><span class="comment">2 5 25</span></span><br><span class="line"><span class="comment">3 4 18</span></span><br><span class="line"><span class="comment">4 6 27</span></span><br><span class="line"><span class="comment">4 7 31</span></span><br><span class="line"><span class="comment">5 6 26</span></span><br><span class="line"><span class="comment">8 9 19</span></span><br><span class="line"><span class="comment">9 7 28</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输出:</span></span><br><span class="line"><span class="comment">C1的邻居有: &#123;C3 权重:10&#125; &#123;C8 权重:15&#125;</span></span><br><span class="line"><span class="comment">C2的邻居有: &#123;C3 权重:20&#125; &#123;C4 权重:35&#125; &#123;C5 权重:25&#125;</span></span><br><span class="line"><span class="comment">C3的邻居有: &#123;C4 权重:18&#125;</span></span><br><span class="line"><span class="comment">C4的邻居有: &#123;C6 权重:27&#125; &#123;C7 权重:31&#125;</span></span><br><span class="line"><span class="comment">C5的邻居有: &#123;C6 权重:26&#125;</span></span><br><span class="line"><span class="comment">C6的邻居有:</span></span><br><span class="line"><span class="comment">C7的邻居有:</span></span><br><span class="line"><span class="comment">C8的邻居有: &#123;C9 权重:19&#125;</span></span><br><span class="line"><span class="comment">C9的邻居有: &#123;C7 权重:28&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="无向图原码"><a href="#无向图原码" class="headerlink" title="无向图原码"></a>无向图原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string data[N];</span><br><span class="line">    <span class="keyword">bool</span> vis[N][N] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//标记是否存在这样的边</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;    <span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">    <span class="keyword">int</span> value[N][N];       <span class="comment">//边的权重</span></span><br><span class="line">&#125; AdjGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_graph</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.arcnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, value;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; value;</span><br><span class="line">        G.vis[a][b] = <span class="number">1</span>;</span><br><span class="line">        G.vis[b][a] = <span class="number">1</span>;</span><br><span class="line">        G.value[a][b] = value;</span><br><span class="line">        G.value[b][a] = value;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; G.data[i] &lt;&lt; <span class="string">&quot;的邻居有:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;=G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.vis[i][j] == <span class="number">1</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; G.data[j] &lt;&lt; <span class="string">&quot; 权重:&quot;</span>&lt;&lt; G.value[i][j] &lt;&lt; <span class="string">&quot;&#125;&quot;</span>&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjGraph G;</span><br><span class="line">    <span class="built_in">create_graph</span>(G);</span><br><span class="line">    <span class="built_in">print</span>(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试样例:</span></span><br><span class="line"><span class="comment">9 11</span></span><br><span class="line"><span class="comment">C1 C2 C3 C4 C5 C6 C7 C8 C9</span></span><br><span class="line"><span class="comment">1 3 10</span></span><br><span class="line"><span class="comment">1 8 15</span></span><br><span class="line"><span class="comment">2 3 20</span></span><br><span class="line"><span class="comment">2 4 35 </span></span><br><span class="line"><span class="comment">2 5 25</span></span><br><span class="line"><span class="comment">3 4 18</span></span><br><span class="line"><span class="comment">4 6 27</span></span><br><span class="line"><span class="comment">4 7 31</span></span><br><span class="line"><span class="comment">5 6 26</span></span><br><span class="line"><span class="comment">8 9 19</span></span><br><span class="line"><span class="comment">9 7 28</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输出:</span></span><br><span class="line"><span class="comment">C1的邻居有: &#123;C3 权重:10&#125; &#123;C8 权重:15&#125;</span></span><br><span class="line"><span class="comment">C2的邻居有: &#123;C3 权重:20&#125; &#123;C4 权重:35&#125; &#123;C5 权重:25&#125;</span></span><br><span class="line"><span class="comment">C3的邻居有: &#123;C1 权重:10&#125; &#123;C2 权重:20&#125; &#123;C4 权重:18&#125;</span></span><br><span class="line"><span class="comment">C4的邻居有: &#123;C2 权重:35&#125; &#123;C3 权重:18&#125; &#123;C6 权重:27&#125; &#123;C7 权重:31&#125;</span></span><br><span class="line"><span class="comment">C5的邻居有: &#123;C2 权重:25&#125; &#123;C6 权重:26&#125;</span></span><br><span class="line"><span class="comment">C6的邻居有: &#123;C4 权重:27&#125; &#123;C5 权重:26&#125;</span></span><br><span class="line"><span class="comment">C7的邻居有: &#123;C4 权重:31&#125; &#123;C9 权重:28&#125;</span></span><br><span class="line"><span class="comment">C8的邻居有: &#123;C1 权重:15&#125; &#123;C9 权重:19&#125;</span></span><br><span class="line"><span class="comment">C9的邻居有: &#123;C7 权重:28&#125; &#123;C8 权重:19&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="邻接表实现"><a href="#邻接表实现" class="headerlink" title="邻接表实现"></a>邻接表实现</h2><h3 id="有向图原码-1"><a href="#有向图原码-1" class="headerlink" title="有向图原码"></a>有向图原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>           //边结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;                  <span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>     <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="keyword">int</span> value;                    <span class="comment">//和边相关的信息(权值等)</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string data;              <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;       <span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VNode AdjList[N];      <span class="comment">//存放各个顶点的数组</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;    <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125; AdjGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;               <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G.vexnum; ++i)             <span class="comment">//输入各点，构造表头(顶点)节点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G.AdjList[i].data;             <span class="comment">//输入顶点值</span></span><br><span class="line">        G.AdjList[i].firstarc = <span class="literal">NULL</span>;         <span class="comment">//初始化表头结点的指针域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= G.arcnum; ++k)             <span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1, v2,welth;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; welth;             <span class="comment">//输入一条边依附的两个顶点以及附带的权值</span></span><br><span class="line">        ArcNode * p = <span class="keyword">new</span> ArcNode;            <span class="comment">//生成一个新的边结点*p</span></span><br><span class="line">        p-&gt;adjvex = v2;</span><br><span class="line">        p-&gt;nextarc = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;value = welth;</span><br><span class="line">        ArcNode * temp = G.AdjList[v1].firstarc; <span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            G.AdjList[v1].firstarc = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(temp-&gt;nextarc != <span class="literal">NULL</span>)</span><br><span class="line">                temp = temp-&gt;nextarc;</span><br><span class="line">            temp-&gt;nextarc = p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        p-&gt;nextarc = G.AdjList[v1].firstarc; //尾插法</span></span><br><span class="line"><span class="comment">//        G.AdjList[v1].firstarc = p;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共有 &quot;</span> &lt;&lt; G.vexnum &lt;&lt; <span class="string">&quot; 个节点，&quot;</span> &lt;&lt; G.arcnum &lt;&lt; <span class="string">&quot; 条边&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;邻接表为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ArcNode *p = G.AdjList[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; G.AdjList[i].data &lt;&lt; <span class="string">&quot; -&gt; NULL&quot;</span>&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; G.AdjList[i].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-&gt; &quot;</span> &lt;&lt; G.AdjList[p-&gt;adjvex].data &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-&gt; NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjGraph G;</span><br><span class="line">    <span class="built_in">CreateGraph</span>(G);</span><br><span class="line">    <span class="built_in">Print</span>(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试样例:</span></span><br><span class="line"><span class="comment">9 11</span></span><br><span class="line"><span class="comment">C1 C2 C3 C4 C5 C6 C7 C8 C9</span></span><br><span class="line"><span class="comment">1 3 10</span></span><br><span class="line"><span class="comment">1 8 15</span></span><br><span class="line"><span class="comment">2 3 20</span></span><br><span class="line"><span class="comment">2 4 35 </span></span><br><span class="line"><span class="comment">2 5 25</span></span><br><span class="line"><span class="comment">3 4 18</span></span><br><span class="line"><span class="comment">4 6 27</span></span><br><span class="line"><span class="comment">4 7 31</span></span><br><span class="line"><span class="comment">5 6 26</span></span><br><span class="line"><span class="comment">8 9 19</span></span><br><span class="line"><span class="comment">9 7 28</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输出:</span></span><br><span class="line"><span class="comment">一共有 9 个节点，11 条边</span></span><br><span class="line"><span class="comment">邻接表为:</span></span><br><span class="line"><span class="comment">C1 -&gt; C3[10] -&gt; C8[15] -&gt; NULL</span></span><br><span class="line"><span class="comment">C2 -&gt; C3[20] -&gt; C4[35] -&gt; C5[25] -&gt; NULL</span></span><br><span class="line"><span class="comment">C3 -&gt; C4[18] -&gt; NULL</span></span><br><span class="line"><span class="comment">C4 -&gt; C6[27] -&gt; C7[31] -&gt; NULL</span></span><br><span class="line"><span class="comment">C5 -&gt; C6[26] -&gt; NULL</span></span><br><span class="line"><span class="comment">C6 -&gt; NULL</span></span><br><span class="line"><span class="comment">C7 -&gt; NULL</span></span><br><span class="line"><span class="comment">C8 -&gt; C9[19] -&gt; NULL</span></span><br><span class="line"><span class="comment">C9 -&gt; C7[28] -&gt; NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="无向图原码-1"><a href="#无向图原码-1" class="headerlink" title="无向图原码"></a>无向图原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有向图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>           //边结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;                  <span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>     <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="keyword">int</span> value;                    <span class="comment">//和边相关的信息(权值等)</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string data;              <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;       <span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VNode AdjList[N];      <span class="comment">//存放各个顶点的数组</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;    <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125; AdjGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;               <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G.vexnum; ++i)             <span class="comment">//输入各点，构造表头(顶点)节点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G.AdjList[i].data;             <span class="comment">//输入顶点值</span></span><br><span class="line">        G.AdjList[i].firstarc = <span class="literal">NULL</span>;         <span class="comment">//初始化表头结点的指针域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= G.arcnum; ++k)             <span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1, v2,welth;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; welth;             <span class="comment">//输入一条边依附的两个顶点以及附带的权值</span></span><br><span class="line">        ArcNode * p = <span class="keyword">new</span> ArcNode;            <span class="comment">//生成一个新的边结点*p</span></span><br><span class="line">        p-&gt;adjvex = v2;</span><br><span class="line">        p-&gt;nextarc = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;value = welth;</span><br><span class="line"></span><br><span class="line">        ArcNode * temp1 = G.AdjList[v1].firstarc; <span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">if</span>(temp1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            G.AdjList[v1].firstarc = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(temp1-&gt;nextarc != <span class="literal">NULL</span>)</span><br><span class="line">                temp1 = temp1-&gt;nextarc;</span><br><span class="line">            temp1-&gt;nextarc = p;</span><br><span class="line">        &#125;</span><br><span class="line">        ArcNode * q = <span class="keyword">new</span> ArcNode;            <span class="comment">//生成一个新的边结点*q</span></span><br><span class="line">        q-&gt;adjvex = v1;</span><br><span class="line">        q-&gt;nextarc = <span class="literal">NULL</span>;</span><br><span class="line">        q-&gt;value = welth;</span><br><span class="line"></span><br><span class="line">        ArcNode * temp2 = G.AdjList[v2].firstarc; <span class="comment">//头插法</span></span><br><span class="line">        <span class="keyword">if</span>(temp2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            G.AdjList[v2].firstarc = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(temp2-&gt;nextarc != <span class="literal">NULL</span>)</span><br><span class="line">                temp2 = temp2-&gt;nextarc;</span><br><span class="line">            temp2-&gt;nextarc = q;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        p-&gt;nextarc = G.AdjList[v1].firstarc; //尾插法</span></span><br><span class="line"><span class="comment">//        G.AdjList[v1].firstarc = p;</span></span><br><span class="line"><span class="comment">//        q-&gt;nextare = G.AdjList[v2].firstarc; //尾插法</span></span><br><span class="line"><span class="comment">//        G.AdjList[v2].firstarc = q;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一共有 &quot;</span> &lt;&lt; G.vexnum &lt;&lt; <span class="string">&quot; 个节点，&quot;</span> &lt;&lt; G.arcnum &lt;&lt; <span class="string">&quot; 条边&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;邻接表为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ArcNode *p = G.AdjList[i].firstarc;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; G.AdjList[i].data &lt;&lt; <span class="string">&quot; -&gt; NULL&quot;</span>&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; G.AdjList[i].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-&gt; &quot;</span> &lt;&lt; G.AdjList[p-&gt;adjvex].data &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-&gt; NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjGraph G;</span><br><span class="line">    <span class="built_in">CreateGraph</span>(G);</span><br><span class="line">    <span class="built_in">Print</span>(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例输入:</span></span><br><span class="line"><span class="comment">9 11</span></span><br><span class="line"><span class="comment">C1 C2 C3 C4 C5 C6 C7 C8 C9</span></span><br><span class="line"><span class="comment">1 3 10</span></span><br><span class="line"><span class="comment">1 8 15</span></span><br><span class="line"><span class="comment">2 3 20</span></span><br><span class="line"><span class="comment">2 4 35 </span></span><br><span class="line"><span class="comment">2 5 25</span></span><br><span class="line"><span class="comment">3 4 18</span></span><br><span class="line"><span class="comment">4 6 27</span></span><br><span class="line"><span class="comment">4 7 31</span></span><br><span class="line"><span class="comment">5 6 26</span></span><br><span class="line"><span class="comment">8 9 19</span></span><br><span class="line"><span class="comment">9 7 28</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输出:</span></span><br><span class="line"><span class="comment">一共有 9 个节点，11 条边</span></span><br><span class="line"><span class="comment">邻接表为:</span></span><br><span class="line"><span class="comment">C1 -&gt; C3[10] -&gt; C8[15] -&gt; NULL</span></span><br><span class="line"><span class="comment">C2 -&gt; C3[20] -&gt; C4[35] -&gt; C5[25] -&gt; NULL</span></span><br><span class="line"><span class="comment">C3 -&gt; C1[10] -&gt; C2[20] -&gt; C4[18] -&gt; NULL</span></span><br><span class="line"><span class="comment">C4 -&gt; C2[35] -&gt; C3[18] -&gt; C6[27] -&gt; C7[31] -&gt; NULL</span></span><br><span class="line"><span class="comment">C5 -&gt; C2[25] -&gt; C6[26] -&gt; NULL</span></span><br><span class="line"><span class="comment">C6 -&gt; C4[27] -&gt; C5[26] -&gt; NULL</span></span><br><span class="line"><span class="comment">C7 -&gt; C4[31] -&gt; C9[28] -&gt; NULL</span></span><br><span class="line"><span class="comment">C8 -&gt; C1[15] -&gt; C9[19] -&gt; NULL</span></span><br><span class="line"><span class="comment">C9 -&gt; C8[19] -&gt; C7[28] -&gt; NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>深度优先搜索是一种在开发爬虫早期使用较多的方法。它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件]文件。在一个HTML文件中，当一个超链被选择后，被链接的HTML文件将执行深度优先搜索，即在搜索其余的超链结果之前必须先完整地搜索单独的一条链。深度优先搜索沿着HTML文件上的超链走到不能再深入为止，然后返回到某一个HTML文件，再继续选择该HTML文件中的其他超链。当不再有其他超链可选择时，说明搜索已经结束——百度百科</li>
<li>它从图中某个结点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中的所有顶点都被访问到为止。</li>
</ul>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>（1）访问顶点v；</p>
<p>（2）从v的未被访问的邻接点中选取一个顶点w，从w出发进行深度优先遍历；</p>
<p>（3）重复上述两步，直至图中所有和v有路径相通的顶点都被访问到。</p>
<h4 id="dfs代码"><a href="#dfs代码" class="headerlink" title="dfs代码"></a>dfs代码</h4><h5 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h5><ul>
<li>dfs遍历特定节点，对其递归调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AdjGraph &amp;G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack &lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    vis[i] = <span class="number">1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(i);</span><br><span class="line">    cout &lt;&lt; G.AdjList[i].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ArcNode *p = G.AdjList[i].firstarc;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        p = G.AdjList[s.<span class="built_in">top</span>()].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[p-&gt;adjvex] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[p-&gt;adjvex]=<span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; G.AdjList[p-&gt;adjvex].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                s.<span class="built_in">push</span>(p-&gt;adjvex);</span><br><span class="line">                p = G.AdjList[p-&gt;adjvex].firstarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p=p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先遍历结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">DFS</span>(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*上面的样例,</span></span><br><span class="line"><span class="comment">对于无向图深度优先遍历结果为:</span></span><br><span class="line"><span class="comment">C1 C3 C2 C4 C6 C5 C7 C9 C8</span></span><br><span class="line"><span class="comment">对于有向图深度优先遍历结果为:</span></span><br><span class="line"><span class="comment">C1 C3 C4 C6 C7 C8 C9 C2 C5</span></span><br></pre></td></tr></table></figure>



<h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历 BFS"></a>广度优先遍历 BFS</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止——百度百科</li>
<li>图的广度优先遍历类似于二叉树的层次遍历</li>
</ul>
<h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>广度优先搜索使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：</p>
<p>（1）顶点v入队列。</p>
<p>（2）当队列非空时则继续执行，否则算法结束。</p>
<p>（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。</p>
<p>（4）查找顶点v的第一个邻接顶点。</p>
<p>（5）若v的邻接顶点未被访问过的，则邻接点入队列。</p>
<p>（6）继续查找顶点v的另一个新的邻接顶点，转到步骤（5）。</p>
<p>​    直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）</p>
<h4 id="bfs代码"><a href="#bfs代码" class="headerlink" title="bfs代码"></a>bfs代码</h4><h5 id="有向图邻接表"><a href="#有向图邻接表" class="headerlink" title="有向图邻接表"></a>有向图邻接表</h5><ul>
<li>将入度为0的节点v入队列，并进行标记，再将v节点所在链表入队列，并进行标记，v节点出队列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(AdjGraph &amp;G)</span>  <span class="comment">//广度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="number">0</span>&#125;; <span class="comment">//用来标记节点是否被访问</span></span><br><span class="line">    queue&lt;VNode&gt; q;    <span class="comment">//定义节点队列</span></span><br><span class="line">    <span class="keyword">int</span> indegree[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ArcNode *temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;i++) <span class="comment">//求各个顶点的入度</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = G.AdjList[i].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[temp-&gt;adjvex]++;</span><br><span class="line">            temp = temp-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             q.<span class="built_in">push</span>(G.AdjList[i]);  <span class="comment">//将入度为零的节点入队</span></span><br><span class="line">             vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        VNode t = q.<span class="built_in">front</span>();     <span class="comment">//临时节点</span></span><br><span class="line">        ArcNode *p = t.firstarc; <span class="comment">//指向节点邻接表的指针</span></span><br><span class="line">        cout &lt;&lt; t.data &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">//打印节点信息</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>) <span class="comment">//将链表的节点入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[p-&gt;adjvex])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(G.AdjList[p-&gt;adjvex]);</span><br><span class="line">                vis[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">//最前面的节点出队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*上面的样例,</span></span><br><span class="line"><span class="comment">对于有向图广度优先遍历结果为:</span></span><br><span class="line"><span class="comment">C1 C2 C3 C8 C4 C5 C9 C6 C7</span></span><br></pre></td></tr></table></figure>

<h5 id="无向图邻接表"><a href="#无向图邻接表" class="headerlink" title="无向图邻接表"></a>无向图邻接表</h5><ul>
<li>从第一个节点开始遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(AdjGraph &amp;G)</span>  <span class="comment">//广度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> vis[N] = &#123;<span class="number">0</span>&#125;; <span class="comment">//用来标记节点是否被访问</span></span><br><span class="line">    queue&lt;VNode&gt; q;    <span class="comment">//定义节点队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(G.AdjList[<span class="number">1</span>]);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        VNode t = q.<span class="built_in">front</span>();     <span class="comment">//临时节点</span></span><br><span class="line">        ArcNode *p = t.firstarc; <span class="comment">//指向节点邻接表的指针</span></span><br><span class="line">        cout &lt;&lt; t.data &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">//打印节点信息</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>) <span class="comment">//将链表的节点入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[p-&gt;adjvex]) <span class="comment">//在此处检查是否被访问过</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(G.AdjList[p-&gt;adjvex]);</span><br><span class="line">                vis[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">//最前面的节点出队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*上面的样例,</span></span><br><span class="line"><span class="comment">对于无向图广度优先遍历结果为:</span></span><br><span class="line"><span class="comment">C1 C3 C8 C2 C4 C9 C5 C6 C7</span></span><br></pre></td></tr></table></figure>



<h2 id="有向无环图的拓扑排序"><a href="#有向无环图的拓扑排序" class="headerlink" title="有向无环图的拓扑排序"></a>有向无环图的拓扑排序</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>有向无环图（Directed Acyclic Graph, DAG）是有向图的一种，字面意思的理解就是图中没有环。常常被用来表示事件之间的驱动依赖关系，管理任务之间的调度。拓扑排序是对DAG的顶点进行排序，使得对每一条有向边(u, v)，均有u（在排序记录中）比v先出现。亦可理解为对某点v而言，只有当v的所有源点均出现了，v才能出现</p>
</li>
<li><p>AOV-网（Activity On Vertex Network）:用顶点表示活动，用弧表示活动间的优先关系的有向无环图，成为顶点表示活动的网，简称AOV-网。特性有活动间的传递性，拓扑序列不唯一</p>
</li>
</ul>
<img src="/2021/07/18/graphs/12.png" class="">

<ul>
<li>拓扑排序（topological sort）其实就是基于有向无环图，遍历所有的结点，每两个结点之间有先后关系。并且在搜索下一个结点的时候，这个结点之前的结点已经全部被搜索过。如果含有环，那么进行拓扑排序是不可能的（不唯一）</li>
</ul>
<h3 id="拓扑排序的基本思想"><a href="#拓扑排序的基本思想" class="headerlink" title="拓扑排序的基本思想"></a>拓扑排序的基本思想</h3><ol>
<li>计算每个顶点的入度，从一个有向图中选取一个无前驱（入度为0）的定点输出；</li>
<li>将此顶点和以它为起点的弧删除；</li>
<li>重复1. 2.；</li>
<li>若此时输出的顶点数小于有向图的顶点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列</li>
</ol>
<h3 id="拓扑排序的算法步骤"><a href="#拓扑排序的算法步骤" class="headerlink" title="拓扑排序的算法步骤"></a>拓扑排序的算法步骤</h3><ol>
<li><p>求出所有顶点的入度，可以附设一个存放各顶点入度的数组indegree</p>
</li>
<li><p>把所有入度为0的顶点入队列或栈</p>
</li>
<li><p>当队列或栈不为空时</p>
<p>​    1）出战或出队列的顶点为u，输出顶点u</p>
<p>​    2)  顶点u的所有邻接点入度减一，如果有入度为0的顶点，则    入栈或入队列</p>
</li>
<li><p>若此时输出的顶点数小于有向图的顶点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列</p>
</li>
</ol>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adj; <span class="comment">//邻接点</span></span><br><span class="line">    node * nextarc;</span><br><span class="line">&#125;arcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    arcNode *firstArc;</span><br><span class="line">&#125;vexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    vexNode adjList[N];</span><br><span class="line">&#125;AdjGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(AdjGraph &amp;g)</span> <span class="comment">//头插法存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; g.n &gt;&gt; g.e; <span class="comment">//输入顶点个数和边的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; g.adjList[i].data;</span><br><span class="line">        g.adjList[i].firstArc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g.e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        arcNode * s = <span class="keyword">new</span> arcNode;</span><br><span class="line">        s-&gt;adj = v;</span><br><span class="line">        s-&gt;nextarc = g.adjList[u].firstArc;</span><br><span class="line">        g.adjList[u].firstArc = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopoSort</span><span class="params">(<span class="keyword">const</span> AdjGraph &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> indegree[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    arcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g.n;i++) <span class="comment">//求各个顶点的入度</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = g.adjList[i].firstArc;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[p-&gt;adj]++;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g.n;i++)<span class="comment">//将入度为0的顶点入栈</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//统计输出顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; g.adjList[u].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//顶点u的所有邻接点的入度减一，如果有入度为0的顶点，则入栈</span></span><br><span class="line">        p = g.adjList[u].firstArc;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[p-&gt;adj]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[p-&gt;adj] == <span class="number">0</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(p-&gt;adj);</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; g.n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//该有向图又回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjGraph g;</span><br><span class="line">    <span class="built_in">createGraph</span>(g);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TopoSort</span>(g) == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 该有向图有回路&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 拓扑排序成功&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试样例:</span></span><br><span class="line"><span class="comment">9 11</span></span><br><span class="line"><span class="comment">C1 C2 C3 C4 C5 C6 C7 C8 C9</span></span><br><span class="line"><span class="comment">0 2</span></span><br><span class="line"><span class="comment">0 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">8 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输出:</span></span><br><span class="line"><span class="comment">C2 C5 C1 C3 C4 C6 C8 C9 C7  拓扑排序成功</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="Dijkstra-（迪杰斯特拉算法）"><a href="#Dijkstra-（迪杰斯特拉算法）" class="headerlink" title="Dijkstra （迪杰斯特拉算法）"></a>Dijkstra （迪杰斯特拉算法）</h3><ul>
<li>Dijstra算法是解决单源最短路径的一般方法，是贪婪算法的最好的实例。该算法要求图中不出现负边权</li>
</ul>
<p>算法步骤</p>
<h6 id="邻接表实现-1"><a href="#邻接表实现-1" class="headerlink" title="邻接表实现"></a>邻接表实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> st[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入起点: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[i] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        st[t] = <span class="number">1</span>;</span><br><span class="line">        ArcNode *p = G.AdjList[t].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[p-&gt;adjvex] &gt; dis[t] + p-&gt;value &amp;&amp; !st[p-&gt;adjvex])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[p-&gt;adjvex] = dis[t] + p-&gt;value;</span><br><span class="line">                q.<span class="built_in">push</span>(p-&gt;adjvex);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= G.vexnum; j++)</span><br><span class="line">        cout &lt;&lt; dis[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="邻接矩阵实现-1"><a href="#邻接矩阵实现-1" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.<span class="built_in">front</span>();</span><br><span class="line">        st[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.vis[j][i] &amp;&amp; dis[j]&gt;dis[i]+G.value[i][j] &amp;&amp; !st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = dis[i] + G.value[i][j];</span><br><span class="line">                s.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="floyed（弗洛伊德算法）"><a href="#floyed（弗洛伊德算法）" class="headerlink" title="floyed（弗洛伊德算法）"></a>floyed（弗洛伊德算法）</h3><h6 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h6><h6 id="邻接表实现-2"><a href="#邻接表实现-2" class="headerlink" title="邻接表实现"></a>邻接表实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyed</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.arcnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ArcNode *p = G.AdjList[i].firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[i][p-&gt;adjvex] = p-&gt;value;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= G.vexnum;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= G.vexnum;j++)</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j] &gt; dis[i][k] + dis[k][j])</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; G.AdjList[i].data &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= G.vexnum;j++)</span><br><span class="line">            cout &lt;&lt; dis[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="邻接矩阵实现-2"><a href="#邻接矩阵实现-2" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyed</span><span class="params">(AdjGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= G.vexnum; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G.vexnum; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= G.vexnum; j++）</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j] &gt;= dis[i][k] + dis[k][j])</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;=G.vexnum; i++)</span><br><span class="line">        cout &lt;&lt; dis[<span class="number">4</span>][i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//输出第四个节点与其它所有节点的最短距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>最小生成树其实是最小权重生成树的简称。我们称求取该生成树的问题成为最小生成树问题。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为最小生成森林。以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低</li>
</ul>
<img src="/2021/07/18/graphs/13.png" class="">

<ul>
<li><p>如图，这个是一个平面图，图中黑色线描述的就是最小生成树，它的权值之和小于其他的生成树。</p>
</li>
<li><p>由最小生成树的定义我们可以知道构建最小生成树是可以利用贪心算法去实现的，我们接下来介绍的两种算法也都是利用贪心算法去求得的。因为贪心算法的策略就是在每一步尽可能多的选择中选择最优的，在当前看是最好的选择，这种策略虽然一般不能在全局中寻找到最优解，但是对于最小生成树问题来说，它的确可以找到一颗权重最小的树</p>
</li>
</ul>
<h3 id="Prim（普利姆）算法"><a href="#Prim（普利姆）算法" class="headerlink" title="Prim（普利姆）算法"></a>Prim（普利姆）算法</h3><ol>
<li><p>简介<br>普里姆算法（Prim’s algorithm），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。（来源于维基百科）</p>
</li>
<li><p>具体步骤<br>Prim算法是利用贪心算法实现的，我们确定根节点，从这个结点出发。普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p>
</li>
<li><p>算法示例图</p>
</li>
</ol>
<img src="/2021/07/18/graphs/15.png" class="14.png} #### 原码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 510</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N];   <span class="comment">//与迪杰斯特拉不同，这里的dis[i]数组存储的是i到距离集合最近的距离</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];  <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">//标记已近加入最小生成树的节点</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis); <span class="comment">//初始化dis数组，设为无穷大</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//记录最小生成树的最小权值总和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)  <span class="comment">//加入n个节点到点集合</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; j++) <span class="comment">//找到距离点集合最小的边所在的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dis[t] &gt; dis[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dis[t] == INF) <span class="keyword">return</span> INF; <span class="comment">//除第一个节点，若没有找到距离点集合最小边所在的节点，说明该点是孤立的</span></span><br><span class="line">        <span class="keyword">if</span>(i) res += dis[t]; <span class="comment">//第一个节点为起点，自己到自己不记录权值</span></span><br><span class="line">        st[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// 更新节点</span></span><br><span class="line">            dis[j] = <span class="built_in">min</span>(dis[j],g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">Prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t == INF)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;impopssible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> #### 堆优化 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 510</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> h[MAXN], e[MAXN], w[MAXN], ne[MAXN],idx;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; <span class="comment">//优先队列，按PII.first 增序排列的队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> ver = t.second, dst = t.first;</span><br><span class="line">        <span class="keyword">if</span>(vis[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[ver] = <span class="literal">true</span>;</span><br><span class="line">        sum += dst;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;w[i], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != n) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(a, b, w);</span><br><span class="line">        <span class="built_in">add</span>(b, a, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">Prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t == INF) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ### kruskal（克鲁斯卡尔）算法 算法描述： * Kruskal算法是基于贪心的思想得到的。首先我们把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。至于怎么合并到一个集合，那么这里我们就可以用到一个工具——-并查集。换而言之，Kruskal算法就是基于并查集的贪心算法 算法步骤： 1. 将图中所有的边都取出来放入一个列表中，按照权值的大小从小到大排列 2. 从列表中取出权值最小的边进行回贴 3. 每进行一次回贴，都要进行一次判断（并查集），为的是判断当前图中是否存在环，如果不存在，该边才算回贴成功 4. 回贴成功一次，记录ans++,当ans&#x3D;&#x3D;顶点数 - 1 时，最小生成树已构建完成 算法示例图： {% asset_img">

<h4 id="原码-1"><a href="#原码-1" class="headerlink" title="原码"></a>原码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)<span class="comment">//i为循环变量，a为初始值，n为界限值，递增</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)<span class="comment">//i为循环变量， a为初始值，n为界限值，递减。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;<span class="comment">//最大值。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt;  pll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//*******************************分割线，以上为自定义代码模板***************************************//</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> s;<span class="comment">//边的起始顶点。</span></span><br><span class="line">	<span class="keyword">int</span> e;<span class="comment">//边的终端顶点。</span></span><br><span class="line">	<span class="keyword">int</span> w;<span class="comment">//边权值。</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;a)&#123;</span><br><span class="line">		<span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">edge temp[maxn];<span class="comment">//临时数组存储边。</span></span><br><span class="line"><span class="keyword">int</span> verx[maxn];<span class="comment">//辅助数组，判断是否连通。</span></span><br><span class="line">edge tree[maxn];<span class="comment">//最小生成树。</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n*n的图，m条边。</span></span><br><span class="line"><span class="keyword">int</span> cnt;<span class="comment">//统计生成结点个数，若不满足n个，则生成失败。</span></span><br><span class="line"><span class="keyword">int</span> sum;<span class="comment">//最小生成树权值总和。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//打印最小生成树函数。</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;最小生成树的权值总和为：&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">		cout&lt;&lt;tree[i].s&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tree[i].e&lt;&lt;<span class="string">&quot;边权值为&quot;</span>&lt;&lt;tree[i].w&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		verx[i]=i;<span class="comment">//这里表示各顶点自成一个连通分量。</span></span><br><span class="line">	cnt=<span class="number">0</span>;sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(temp,temp+m);<span class="comment">//将边按权值排列。</span></span><br><span class="line">	<span class="keyword">int</span> v1,v2;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">		v1=verx[temp[i].s];</span><br><span class="line">		v2=verx[temp[i].e];</span><br><span class="line">		<span class="keyword">if</span>(v1!=v2)&#123;</span><br><span class="line">			tree[cnt].s=temp[i].s;tree[cnt].e=temp[i].e;tree[cnt].w=temp[i].w;<span class="comment">//并入最小生成树。</span></span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">				<span class="comment">//合并v1和v2的两个分量，即两个集合统一编号。</span></span><br><span class="line">				<span class="keyword">if</span>(verx[j]==v2)verx[j]=v1; <span class="comment">//默认集合编号为v2的改为v1.</span></span><br><span class="line">			&#125;</span><br><span class="line">			sum+=tree[cnt].w;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//结束双层for循环之后得到tree即是最小生成树。</span></span><br><span class="line">	<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);//提交的时候要注释掉</span></span><br><span class="line">	IOS;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			temp[i].s=u;temp[i].e=v;temp[i].w=w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Kruskal</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AlbertH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/18/graphs/">http://example.com/2021/07/18/graphs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/06/28/Algorithm/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Algorithm</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">AlbertH</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Gainmoreso"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#graphs"><span class="toc-number">1.</span> <span class="toc-text">graphs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">图的基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">图的基本属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">图的表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">边列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">邻接表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">邻接矩阵实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E5%8E%9F%E7%A0%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">有向图原码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E5%8E%9F%E7%A0%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">无向图原码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">邻接表实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E5%8E%9F%E7%A0%81-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">有向图原码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E5%8E%9F%E7%A0%81-1"><span class="toc-number">1.5.2.</span> <span class="toc-text">无向图原码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">dfs代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-1"><span class="toc-number">1.6.1.3.1.</span> <span class="toc-text">邻接表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFS"><span class="toc-number">1.6.2.</span> <span class="toc-text">广度优先遍历 BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bfs%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">bfs代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text">有向图邻接表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.6.2.3.2.</span> <span class="toc-text">无向图邻接表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">有向无环图的拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.7.2.</span> <span class="toc-text">拓扑排序的基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.7.3.</span> <span class="toc-text">拓扑排序的算法步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81"><span class="toc-number">1.7.4.</span> <span class="toc-text">原码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra-%EF%BC%88%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">Dijkstra （迪杰斯特拉算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.8.1.0.0.1.</span> <span class="toc-text">邻接表实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.8.1.0.0.2.</span> <span class="toc-text">邻接矩阵实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floyed%EF%BC%88%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">floyed（弗洛伊德算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">1.8.2.0.0.1.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.8.2.0.0.2.</span> <span class="toc-text">邻接表实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.8.2.0.0.3.</span> <span class="toc-text">邻接矩阵实现</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.9.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%EF%BC%88%E6%99%AE%E5%88%A9%E5%A7%86%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">Prim（普利姆）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81-1"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">原码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">1.10.</span> <span class="toc-text">字典树</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/18/graphs/" title="graphs"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="graphs"/></a><div class="content"><a class="title" href="/2021/07/18/graphs/" title="graphs">graphs</a><time datetime="2021-07-17T16:00:00.000Z" title="发表于 2021-07-18 00:00:00">2021-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/28/Algorithm/" title="Algorithm"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Algorithm"/></a><div class="content"><a class="title" href="/2021/06/28/Algorithm/" title="Algorithm">Algorithm</a><time datetime="2021-06-28T08:59:11.000Z" title="发表于 2021-06-28 16:59:11">2021-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/27/%E4%BB%8E2-3-4%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/" title="从2-3-4树到红黑树"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从2-3-4树到红黑树"/></a><div class="content"><a class="title" href="/2021/04/27/%E4%BB%8E2-3-4%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/" title="从2-3-4树到红黑树">从2-3-4树到红黑树</a><time datetime="2021-04-27T13:25:04.000Z" title="发表于 2021-04-27 21:25:04">2021-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/25/AVL-tree/" title="AVL tree"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AVL tree"/></a><div class="content"><a class="title" href="/2021/04/25/AVL-tree/" title="AVL tree">AVL tree</a><time datetime="2021-04-25T02:04:41.000Z" title="发表于 2021-04-25 10:04:41">2021-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/" title="Counting sort （计数排序）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Counting sort （计数排序）"/></a><div class="content"><a class="title" href="/2021/04/24/Counting-sort-%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/" title="Counting sort （计数排序）">Counting sort （计数排序）</a><time datetime="2021-04-24T13:33:35.000Z" title="发表于 2021-04-24 21:33:35">2021-04-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By AlbertH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>